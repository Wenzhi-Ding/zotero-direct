/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/zotero-db.ts
var zotero_db_exports = {};
__export(zotero_db_exports, {
  getDbModificationTime: () => getDbModificationTime,
  readZoteroDatabase: () => readZoteroDatabase,
  readZoteroDatabaseIncremental: () => readZoteroDatabaseIncremental
});
function loadSqlJsFromPluginDir(pluginDir) {
  return __async(this, null, function* () {
    const wasmPath = path.join(pluginDir, "sql-wasm.wasm");
    if (!fs.existsSync(wasmPath)) {
      throw new Error(`\u7F3A\u5C11 sql-wasm.wasm \u6587\u4EF6\uFF0C\u8BF7\u786E\u4FDD\u6587\u4EF6\u5B58\u5728\u4E8E: ${wasmPath}`);
    }
    const wasmBinary = fs.readFileSync(wasmPath).buffer;
    const g = globalThis;
    if (g.initSqlJs) {
      return g.initSqlJs({ wasmBinary });
    }
    const sqlJsPath = path.join(pluginDir, "sql-wasm.js");
    if (!fs.existsSync(sqlJsPath)) {
      throw new Error(`\u7F3A\u5C11 sql-wasm.js \u6587\u4EF6\uFF0C\u8BF7\u786E\u4FDD\u6587\u4EF6\u5B58\u5728\u4E8E: ${sqlJsPath}`);
    }
    const sqlJsContent = fs.readFileSync(sqlJsPath, "utf-8");
    const loader = new Function("globalThis", "window", "global", "module", "exports", `
		${sqlJsContent}
		return typeof initSqlJs !== 'undefined' ? initSqlJs : undefined;
	`);
    const initSqlJs = loader(globalThis, globalThis, globalThis, void 0, void 0);
    if (!initSqlJs) {
      throw new Error("sql-wasm.js \u52A0\u8F7D\u5931\u8D25\uFF0C\u672A\u627E\u5230 initSqlJs \u51FD\u6570");
    }
    globalThis.initSqlJs = initSqlJs;
    return yield initSqlJs({ wasmBinary });
  });
}
function initSql(pluginDir) {
  return __async(this, null, function* () {
    if (cachedSqlJs) return cachedSqlJs;
    if (sqlJsLoadingPromise) {
      return sqlJsLoadingPromise;
    }
    if (!pluginDir) {
      throw new Error("\u9996\u6B21\u52A0\u8F7D sql.js \u9700\u8981\u63D0\u4F9B pluginDir \u53C2\u6570");
    }
    sqlJsLoadingPromise = loadSqlJsFromPluginDir(pluginDir);
    cachedSqlJs = yield sqlJsLoadingPromise;
    return cachedSqlJs;
  });
}
function query(db, sql) {
  const results = db.exec(sql);
  if (!results.length) return [];
  const result = results[0];
  if (!result) return [];
  const { columns, values } = result;
  return values.map((row) => {
    const obj = {};
    columns.forEach((col, i) => obj[col] = row[i]);
    return obj;
  });
}
function getDbModificationTime(dbPath) {
  if (!fs.existsSync(dbPath)) return 0;
  return fs.statSync(dbPath).mtimeMs;
}
function readZoteroDatabase(dbPath, pluginDir) {
  return __async(this, null, function* () {
    if (!fs.existsSync(dbPath)) {
      throw new Error("Zotero database not found at: " + dbPath);
    }
    const SQL = yield initSql(pluginDir);
    const buffer = fs.readFileSync(dbPath);
    const db = new SQL.Database(new Uint8Array(buffer));
    let bbtCiteKeys = {};
    const bbtDbPath = path.join(path.dirname(dbPath), "better-bibtex.sqlite");
    if (fs.existsSync(bbtDbPath)) {
      try {
        const bbtBuf = fs.readFileSync(bbtDbPath);
        const bbtDb = new SQL.Database(new Uint8Array(bbtBuf));
        bbtCiteKeys = extractBBTCiteKeys(bbtDb);
        bbtDb.close();
      } catch (e) {
        console.warn("Could not read BetterBibTeX database:", e);
      }
    }
    try {
      const items = extractItems(db, bbtCiteKeys, dbPath);
      const collections = extractCollections(db);
      return { items, collections };
    } finally {
      db.close();
    }
  });
}
function readZoteroDatabaseIncremental(_0, _1) {
  return __async(this, arguments, function* (dbPath, sinceTimestamp, bbtCiteKeys = {}, pluginDir = "") {
    if (!fs.existsSync(dbPath)) {
      throw new Error("Zotero database not found at: " + dbPath);
    }
    const SQL = yield initSql(pluginDir);
    const buffer = fs.readFileSync(dbPath);
    const db = new SQL.Database(new Uint8Array(buffer));
    if (Object.keys(bbtCiteKeys).length === 0) {
      const bbtDbPath = path.join(path.dirname(dbPath), "better-bibtex.sqlite");
      if (fs.existsSync(bbtDbPath)) {
        try {
          const bbtBuf = fs.readFileSync(bbtDbPath);
          const bbtDb = new SQL.Database(new Uint8Array(bbtBuf));
          bbtCiteKeys = extractBBTCiteKeys(bbtDb);
          bbtDb.close();
        } catch (e) {
          console.warn("Could not read BetterBibTeX database:", e);
        }
      }
    }
    try {
      const sinceDate = new Date(sinceTimestamp).toISOString();
      const items = query(
        db,
        `SELECT i.itemID, it.typeName AS itemType, i.key AS itemKey,
			        i.dateAdded, i.dateModified, i.libraryID
			 FROM items i
			 JOIN itemTypes it ON i.itemTypeID = it.itemTypeID
			 WHERE it.typeName NOT IN ('attachment', 'note', 'annotation')
			   AND i.itemID NOT IN (SELECT itemID FROM deletedItems)
			   AND (i.dateModified > '${sinceDate}' OR i.dateAdded > '${sinceDate}')`
      );
      if (items.length === 0) {
        return null;
      }
      const itemIds = items.map((i) => i.itemID).join(",");
      const fieldRows = query(
        db,
        `SELECT id.itemID, f.fieldName, idv.value
				 FROM itemData id
				 JOIN fields f      ON id.fieldID  = f.fieldID
				 JOIN itemDataValues idv ON id.valueID = idv.valueID
				 WHERE id.itemID IN (${itemIds})`
      );
      const creatorRows = query(
        db,
        `SELECT ic.itemID, c.firstName, c.lastName, c.fieldMode,
						ct.creatorType, ic.orderIndex
				 FROM itemCreators ic
				 JOIN creators    c  ON ic.creatorID     = c.creatorID
				 JOIN creatorTypes ct ON ic.creatorTypeID = ct.creatorTypeID
				 WHERE ic.itemID IN (${itemIds})
				 ORDER BY ic.itemID, ic.orderIndex`
      );
      const tagRows = query(
        db,
        `SELECT it.itemID, t.name AS tag
				 FROM itemTags it
				 JOIN tags t ON it.tagID = t.tagID
				 WHERE it.itemID IN (${itemIds})`
      );
      const fieldsByItem = {};
      for (const f of fieldRows) {
        if (!fieldsByItem[f.itemID]) fieldsByItem[f.itemID] = {};
        fieldsByItem[f.itemID][f.fieldName] = f.value;
      }
      const creatorsByItem = {};
      for (const c of creatorRows) {
        if (!creatorsByItem[c.itemID]) creatorsByItem[c.itemID] = [];
        if (c.fieldMode === 1) {
          creatorsByItem[c.itemID].push({
            creatorType: String(c.creatorType || ""),
            firstName: "",
            lastName: "",
            name: String(c.lastName || "")
          });
        } else {
          creatorsByItem[c.itemID].push({
            creatorType: String(c.creatorType || ""),
            firstName: String(c.firstName || ""),
            lastName: String(c.lastName || ""),
            name: ""
          });
        }
      }
      const tagsByItem = {};
      for (const t2 of tagRows) {
        if (!tagsByItem[t2.itemID]) tagsByItem[t2.itemID] = [];
        tagsByItem[t2.itemID].push({ tag: String(t2.tag) });
      }
      const references = [];
      const updatedItemKeys = [];
      for (const item of items) {
        const itemID = item.itemID;
        const itemKey = String(item.itemKey || "");
        const itemType = String(item.itemType || "");
        const fields = fieldsByItem[itemID] || {};
        let citationKey = "";
        if (bbtCiteKeys[itemID]) {
          citationKey = bbtCiteKeys[itemID];
        } else if (fields.citationKey) {
          citationKey = fields.citationKey;
        } else if (fields.extra) {
          const m = fields.extra.match(/^Citation Key:\s*(.+)$/im);
          if (m) citationKey = m[1].trim();
        }
        if (!citationKey) continue;
        updatedItemKeys.push(citationKey);
        const ref = {
          itemID,
          itemKey,
          citationKey,
          citeKey: citationKey,
          itemType,
          title: (fields.title || fields.nameOfAct || "").replace(/^'|'$/g, ""),
          date: fields.date || fields.dateEnacted || "",
          dateModified: String(item.dateModified || ""),
          publicationTitle: fields.publicationTitle || fields.journalAbbreviation || (itemType === "conferencePaper" ? fields.series : "") || (itemType === "statute" ? fields.code : "") || "",
          volume: fields.volume || "",
          issue: fields.issue || "",
          pages: fields.pages || "",
          // Extended fields for search
          abstractNote: fields.abstractNote || "",
          DOI: fields.DOI || "",
          ISBN: fields.ISBN || "",
          ISSN: fields.ISSN || "",
          url: fields.url || "",
          dateAdded: String(item.dateAdded || ""),
          creators: creatorsByItem[itemID] || [],
          tags: tagsByItem[itemID] || [],
          attachments: [],
          notes: [],
          select: `zotero://select/library/items/${itemKey}`,
          authorKey: "",
          authorKeyInitials: "",
          authorKeyFullName: "",
          id: itemID,
          year: "",
          citationInLine: "",
          citationInLineInitials: "",
          citationInLineFullName: "",
          citationShort: "",
          citationFull: "",
          inlineReference: "",
          file: "",
          filePath: "",
          zoteroReaderLink: "",
          localLibrary: "",
          localLibraryLink: "",
          zoteroTags: []
        };
        for (const [key, value] of Object.entries(fields)) {
          if (!(key in ref)) {
            ref[key] = value;
          }
        }
        references.push(ref);
      }
      const collections = extractCollections(db);
      return { items: references, updatedItemKeys, collections };
    } finally {
      db.close();
    }
  });
}
function extractBBTCiteKeys(db) {
  var _a;
  const keys = {};
  try {
    const rows = query(
      db,
      `SELECT * FROM "better-bibtex" WHERE name = 'better-bibtex.citekey'`
    );
    if (rows.length > 0 && ((_a = rows[0]) == null ? void 0 : _a.value)) {
      const parsed = JSON.parse(String(rows[0].value));
      if (Array.isArray(parsed == null ? void 0 : parsed.data)) {
        for (const entry of parsed.data) {
          if (entry.itemID && entry.citekey) {
            keys[entry.itemID] = entry.citekey;
          }
        }
      }
    }
  } catch (e) {
    try {
      const rows = query(
        db,
        `SELECT itemID, citationKey FROM citationkey`
      );
      for (const row of rows) {
        keys[row.itemID] = String(row.citationKey);
      }
    } catch (e2) {
      console.warn("Could not extract BBT citation keys from any known schema");
    }
  }
  return keys;
}
function extractItems(db, bbtCiteKeys, dbPath) {
  const items = query(
    db,
    `SELECT i.itemID, it.typeName AS itemType, i.key AS itemKey,
		        i.dateAdded, i.dateModified, i.libraryID
		 FROM items i
		 JOIN itemTypes it ON i.itemTypeID = it.itemTypeID
		 WHERE it.typeName NOT IN ('attachment', 'note', 'annotation')
		   AND i.itemID NOT IN (SELECT itemID FROM deletedItems)`
  );
  const fieldRows = query(
    db,
    `SELECT id.itemID, f.fieldName, idv.value
		 FROM itemData id
		 JOIN fields f      ON id.fieldID  = f.fieldID
		 JOIN itemDataValues idv ON id.valueID = idv.valueID`
  );
  const fieldsByItem = {};
  for (const f of fieldRows) {
    if (!fieldsByItem[f.itemID]) fieldsByItem[f.itemID] = {};
    fieldsByItem[f.itemID][f.fieldName] = f.value;
  }
  const creatorRows = query(
    db,
    `SELECT ic.itemID, c.firstName, c.lastName, c.fieldMode,
				ct.creatorType, ic.orderIndex
		 FROM itemCreators ic
		 JOIN creators    c  ON ic.creatorID     = c.creatorID
		 JOIN creatorTypes ct ON ic.creatorTypeID = ct.creatorTypeID
		 ORDER BY ic.itemID, ic.orderIndex`
  );
  const creatorsByItem = {};
  for (const c of creatorRows) {
    if (!creatorsByItem[c.itemID]) creatorsByItem[c.itemID] = [];
    if (c.fieldMode === 1) {
      creatorsByItem[c.itemID].push({
        creatorType: String(c.creatorType || ""),
        firstName: "",
        lastName: "",
        name: String(c.lastName || "")
      });
    } else {
      creatorsByItem[c.itemID].push({
        creatorType: String(c.creatorType || ""),
        firstName: String(c.firstName || ""),
        lastName: String(c.lastName || ""),
        name: ""
      });
    }
  }
  const tagRows = query(
    db,
    `SELECT it.itemID, t.name AS tag
		 FROM itemTags it
		 JOIN tags t ON it.tagID = t.tagID`
  );
  const tagsByItem = {};
  for (const t2 of tagRows) {
    if (!tagsByItem[t2.itemID]) tagsByItem[t2.itemID] = [];
    tagsByItem[t2.itemID].push({ tag: String(t2.tag) });
  }
  const zoteroDir = path.dirname(dbPath);
  const attachRows = query(
    db,
    `SELECT ia.parentItemID, ia.path, ia.contentType,
		        i.key AS itemKey, i.dateAdded, i.dateModified,
		        (SELECT idv2.value
		         FROM itemData id2
		         JOIN fields f2          ON id2.fieldID = f2.fieldID AND f2.fieldName = 'title'
		         JOIN itemDataValues idv2 ON id2.valueID = idv2.valueID
		         WHERE id2.itemID = ia.itemID) AS title
		 FROM itemAttachments ia
		 JOIN items i ON ia.itemID = i.itemID
		 WHERE ia.parentItemID IS NOT NULL
		   AND i.itemID NOT IN (SELECT itemID FROM deletedItems)`
  );
  const attachmentsByItem = {};
  for (const a of attachRows) {
    const parentItemID = a.parentItemID;
    if (!attachmentsByItem[parentItemID])
      attachmentsByItem[parentItemID] = [];
    let filePath = String(a.path || "");
    let title = String(a.title || "");
    const itemKey = String(a.itemKey || "");
    if (filePath.startsWith("storage:")) {
      const filename = filePath.replace("storage:", "");
      filePath = path.join(zoteroDir, "storage", itemKey, filename);
      if (!title) title = filename;
    } else {
      if (!title) title = path.basename(filePath);
    }
    attachmentsByItem[parentItemID].push({
      dateAdded: a.dateAdded,
      dateModified: a.dateModified,
      itemType: "attachment",
      path: filePath,
      relations: [],
      select: `zotero://select/library/items/${itemKey}`,
      tags: [],
      title,
      uri: ""
    });
  }
  const noteRows = query(
    db,
    `SELECT n.parentItemID, n.note, n.title,
		        i.key, i.dateAdded, i.dateModified
		 FROM itemNotes n
		 JOIN items i ON n.itemID = i.itemID
		 WHERE n.parentItemID IS NOT NULL
		   AND i.itemID NOT IN (SELECT itemID FROM deletedItems)`
  );
  const notesByItem = {};
  for (const n of noteRows) {
    const parentItemID = n.parentItemID;
    if (!notesByItem[parentItemID]) notesByItem[parentItemID] = [];
    notesByItem[parentItemID].push({
      dateAdded: n.dateAdded,
      dateModified: n.dateModified,
      itemType: "note",
      key: n.key,
      note: String(n.note || ""),
      parentItem: "",
      relations: [],
      tags: [],
      uri: "",
      version: 0
    });
  }
  const references = [];
  for (const item of items) {
    const itemID = item.itemID;
    const itemKey = String(item.itemKey || "");
    const itemType = String(item.itemType || "");
    const fields = fieldsByItem[itemID] || {};
    let citationKey = "";
    if (bbtCiteKeys[itemID]) {
      citationKey = bbtCiteKeys[itemID];
    } else if (fields.citationKey) {
      citationKey = fields.citationKey;
    } else if (fields.extra) {
      const m = fields.extra.match(/^Citation Key:\s*(.+)$/im);
      if (m) citationKey = m[1].trim();
    }
    if (!citationKey) continue;
    const ref = {
      // ── identifiers ──
      itemID,
      itemKey,
      citationKey,
      citeKey: citationKey,
      itemType,
      // ── basic metadata ──
      title: fields.title || fields.nameOfAct || "",
      date: fields.date || fields.dateEnacted || "",
      dateModified: String(item.dateModified || ""),
      publicationTitle: fields.publicationTitle || fields.journalAbbreviation || (itemType === "conferencePaper" ? fields.series : "") || (itemType === "statute" ? fields.code : "") || "",
      volume: fields.volume || "",
      issue: fields.issue || "",
      pages: fields.pages || "",
      // ── relationships ──
      creators: creatorsByItem[itemID] || [],
      tags: tagsByItem[itemID] || [],
      attachments: attachmentsByItem[itemID] || [],
      notes: notesByItem[itemID] || [],
      // ── Zotero links ──
      select: `zotero://select/library/items/${itemKey}`,
      // ── Fields populated later by parseMetadata ──
      authorKey: "",
      authorKeyInitials: "",
      authorKeyFullName: "",
      id: itemID,
      year: "",
      citationInLine: "",
      citationInLineInitials: "",
      citationInLineFullName: "",
      citationShort: "",
      citationFull: "",
      inlineReference: "",
      file: "",
      filePath: "",
      zoteroReaderLink: "",
      localLibrary: "",
      localLibraryLink: "",
      zoteroTags: []
    };
    for (const [key, value] of Object.entries(fields)) {
      if (!(key in ref)) {
        ref[key] = value;
      }
    }
    references.push(ref);
  }
  return references;
}
function extractCollections(db) {
  const collRows = query(
    db,
    `SELECT c.collectionID, c.collectionName AS name,
		        c.key, c.parentCollectionID
		 FROM collections c`
  );
  const idToKey = {};
  for (const c of collRows) {
    idToKey[c.collectionID] = String(c.key);
  }
  const ciRows = query(
    db,
    `SELECT ci.collectionID, ci.itemID
		 FROM collectionItems ci`
  );
  const itemsByCollection = {};
  for (const ci of ciRows) {
    if (!itemsByCollection[ci.collectionID])
      itemsByCollection[ci.collectionID] = [];
    itemsByCollection[ci.collectionID].push(ci.itemID);
  }
  const result = {};
  for (const c of collRows) {
    const key = String(c.key);
    result[key] = {
      collections: [],
      items: (itemsByCollection[c.collectionID] || []).map(String),
      key,
      name: String(c.name || ""),
      parent: c.parentCollectionID ? idToKey[c.parentCollectionID] || "" : ""
    };
  }
  return result;
}
var fs, path, cachedSqlJs, sqlJsLoadingPromise;
var init_zotero_db = __esm({
  "src/zotero-db.ts"() {
    fs = __toESM(require("fs"), 1);
    path = __toESM(require("path"), 1);
    cachedSqlJs = null;
    sqlJsLoadingPromise = null;
  }
});

// src/zotero-cache.ts
var zotero_cache_exports = {};
__export(zotero_cache_exports, {
  ZoteroCacheManager: () => ZoteroCacheManager,
  clearCacheManager: () => clearCacheManager,
  getCacheManager: () => getCacheManager
});
function getCacheManager(app, dbPath) {
  if (!cacheManager || cacheManager["dbPath"] !== dbPath) {
    cacheManager = new ZoteroCacheManager(app, dbPath);
  }
  return cacheManager;
}
function clearCacheManager() {
  cacheManager = null;
}
var import_obsidian3, ZoteroCacheManager, cacheManager;
var init_zotero_cache = __esm({
  "src/zotero-cache.ts"() {
    import_obsidian3 = require("obsidian");
    init_zotero_db();
    ZoteroCacheManager = class {
      constructor(app, dbPath) {
        this.cache = null;
        this.cacheFilePath = "";
        this.dbPath = "";
        this.app = app;
        this.dbPath = dbPath;
        this.cacheFilePath = this.getCacheFilePath();
      }
      /**
       * Get the path to the cache file (vault-relative, stored in plugin data folder)
       */
      getCacheFilePath() {
        return (0, import_obsidian3.normalizePath)(this.app.vault.configDir + "/plugins/zotero-direct/zotero-cache.json");
      }
      /**
       * Load cache from disk
       */
      loadCache() {
        return __async(this, null, function* () {
          try {
            if (!(yield this.app.vault.adapter.exists(this.cacheFilePath))) {
              return null;
            }
            const data = yield this.app.vault.adapter.read(this.cacheFilePath);
            const cache = JSON.parse(data);
            if (!cache.itemIndex) {
              cache.itemIndex = this.buildItemIndex(cache.items);
            }
            this.cache = cache;
            return cache;
          } catch (e) {
            console.warn("[BibNotes] Failed to load cache:", e);
            return null;
          }
        });
      }
      /**
       * Save cache to disk
       */
      saveCache() {
        return __async(this, null, function* () {
          try {
            if (this.cache) {
              this.cache.itemIndex = this.buildItemIndex(this.cache.items);
              yield this.app.vault.adapter.write(this.cacheFilePath, JSON.stringify(this.cache, null, 2));
            }
          } catch (e) {
            console.warn("[BibNotes] Failed to save cache:", e);
          }
        });
      }
      /**
       * Build citationKey -> index mapping for fast lookup
       */
      buildItemIndex(items) {
        const index = {};
        items.forEach((item, i) => {
          if (item.citationKey) {
            index[item.citationKey] = i;
          }
        });
        return index;
      }
      /**
       * Check if database has been modified since last cache
       */
      hasDbChanged() {
        return __async(this, null, function* () {
          const dbModifiedTime = getDbModificationTime(this.dbPath);
          if (dbModifiedTime === 0) return true;
          if (!this.cache) return true;
          return dbModifiedTime > this.cache.dbLastModified;
        });
      }
      /**
       * Get database modification time
       */
      getDbLastModified() {
        return getDbModificationTime(this.dbPath);
      }
      /**
       * Get cached data (returns null if cache is empty)
       */
      getCache() {
        return this.cache;
      }
      /**
       * Update cache with new/updated items
       */
      updateCache(items, collections, updatedItemKeys) {
        const dbLastModified = this.getDbLastModified();
        if (!this.cache) {
          this.cache = {
            version: 1,
            lastModified: (/* @__PURE__ */ new Date()).toISOString(),
            dbLastModified,
            items,
            collections,
            itemIndex: this.buildItemIndex(items)
          };
        } else {
          if (updatedItemKeys && updatedItemKeys.length > 0) {
            for (const item of items) {
              const existingIndex = this.cache.itemIndex[item.citationKey];
              if (existingIndex !== void 0) {
                this.cache.items[existingIndex] = item;
              } else {
                this.cache.items.push(item);
              }
            }
            this.cache.itemIndex = this.buildItemIndex(this.cache.items);
          } else {
            this.cache.items = items;
            this.cache.collections = collections;
            this.cache.itemIndex = this.buildItemIndex(items);
          }
          this.cache.dbLastModified = dbLastModified;
          this.cache.lastModified = (/* @__PURE__ */ new Date()).toISOString();
        }
      }
      /**
       * Get item by citation key (fast lookup using index)
       */
      getItemByCitationKey(citationKey) {
        var _a;
        if (!this.cache || !this.cache.itemIndex) {
          return null;
        }
        const index = this.cache.itemIndex[citationKey];
        if (index !== void 0 && index >= 0 && index < this.cache.items.length) {
          return (_a = this.cache.items[index]) != null ? _a : null;
        }
        return null;
      }
      /**
       * Search items by keyword (searches title, abstract, authors, keywords)
       * Supports combination search with multiple keywords separated by spaces.
       * Items matching all keywords are prioritized and sorted by match score.
       */
      searchItems(query2) {
        const results = this.searchItemsWithScore(query2);
        return results.map((r) => r.item);
      }
      /**
       * Search items and return with scores for advanced sorting
       */
      searchItemsWithScore(query2) {
        if (!this.cache) {
          return [];
        }
        const lowerQuery = query2.toLowerCase().trim();
        if (!lowerQuery) {
          return this.cache.items.map((item) => ({ item, score: 0, matchesAllKeywords: true }));
        }
        const keywords = lowerQuery.split(/\s+/).filter((kw) => kw.length > 0);
        const scoredItems = [];
        for (const item of this.cache.items) {
          const searchableText = this.getSearchableText(item);
          const scoreResult = this.calculateMatchScore(searchableText, keywords);
          if (scoreResult.score > 0) {
            scoredItems.push({
              item,
              score: scoreResult.score,
              matchesAllKeywords: scoreResult.matchesAll
            });
          }
        }
        scoredItems.sort((a, b) => {
          if (a.matchesAllKeywords !== b.matchesAllKeywords) {
            return a.matchesAllKeywords ? -1 : 1;
          }
          return b.score - a.score;
        });
        return scoredItems;
      }
      /**
       * Get searchable text from item fields
       */
      getSearchableText(item) {
        const parts = [];
        if (item.title) parts.push(item.title);
        if (item.abstractNote) parts.push(item.abstractNote);
        if (item.authorKey) parts.push(item.authorKey);
        if (item.authorFullNames) parts.push(...item.authorFullNames);
        if (item.keywords) parts.push(...item.keywords);
        if (item.tags) parts.push(...item.tags.map((t2) => t2.tag));
        if (item.jelCodes) parts.push(...item.jelCodes);
        if (item.publicationTitle) parts.push(item.publicationTitle);
        if (item.citationKey) parts.push(item.citationKey);
        return parts.join(" ").toLowerCase();
      }
      /**
       * Calculate match score for an item
       * Returns score and whether all keywords were matched
       */
      calculateMatchScore(text, keywords) {
        let totalScore = 0;
        let matchedKeywords = 0;
        for (const keyword of keywords) {
          let keywordScore = 0;
          if (text.includes(keyword)) {
            keywordScore += 100;
            const wordBoundaryRegex = new RegExp(`\\b${this.escapeRegex(keyword)}\\b`, "i");
            if (wordBoundaryRegex.test(text)) {
              keywordScore += 50;
            }
            if (text.toLowerCase().includes(keyword.toLowerCase())) {
              keywordScore += 25;
            }
          }
          if (keywordScore === 0) {
            const words = text.split(/\s+/);
            for (const word of words) {
              if (word.startsWith(keyword)) {
                keywordScore += 30;
                break;
              }
            }
          }
          if (keywordScore > 0) {
            totalScore += keywordScore;
            matchedKeywords++;
          }
        }
        if (matchedKeywords === keywords.length && keywords.length > 1) {
          totalScore += matchedKeywords * 200;
        }
        return {
          score: totalScore,
          matchesAll: matchedKeywords === keywords.length
        };
      }
      /**
       * Escape special regex characters
       */
      escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      /**
       * Clear cache
       */
      clearCache() {
        return __async(this, null, function* () {
          this.cache = null;
          try {
            if (yield this.app.vault.adapter.exists(this.cacheFilePath)) {
              yield this.app.vault.adapter.remove(this.cacheFilePath);
            }
          } catch (e) {
            console.warn("[BibNotes] Failed to clear cache file:", e);
          }
        });
      }
      /**
       * Get cache statistics
       */
      getCacheStats() {
        var _a, _b, _c, _d, _e, _f;
        return {
          itemCount: (_b = (_a = this.cache) == null ? void 0 : _a.items.length) != null ? _b : 0,
          lastModified: (_d = (_c = this.cache) == null ? void 0 : _c.lastModified) != null ? _d : null,
          dbLastModified: (_f = (_e = this.cache) == null ? void 0 : _e.dbLastModified) != null ? _f : 0
        };
      }
    };
    cacheManager = null;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZoteroDirectPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key)) destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n") indexEnd--;
  return string.substring(0, indexEnd);
}
function trimNewlines(string) {
  return trimTrailingNewlines(trimLeadingNewlines(string));
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options) {
    return options.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = trimNewlines(content).replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options) {
    var prefix = options.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + ".  ";
    }
    var isParagraph = /\n$/.test(content);
    content = trimNewlines(content) + (isParagraph ? "\n" : "");
    content = content.replace(/\n/gm, "\n" + " ".repeat(prefix.length));
    return prefix + content + (node.nextSibling ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code = node.firstChild.textContent;
    var fenceChar = options.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options) {
    return "\n\n" + options.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options) {
    return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    if (href) href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options) {
    return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference = "[" + id + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options) {
    if (!content.trim()) return "";
    return options.emDelimiter + content + options.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options) {
    if (!content.trim()) return "";
    return options.strongDelimiter + content + options.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content) return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + "`";
    return delimiter + extraSpace + content + extraSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options) {
  this.options = options;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options.blankReplacement
  };
  this.keepReplacement = options.keepReplacement;
  this.defaultRule = {
    replacement: options.defaultReplacement
  };
  this.array = [];
  for (var key in options.rules) this.array.push(options.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank) return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options)) return rule;
    if (rule = findRule(this._keep, node, this.options)) return rule;
    if (rule = findRule(this._remove, node, this.options)) return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);
  }
};
function findRule(rules2, node, options) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options)) return rule;
  }
  return void 0;
}
function filterValue(rule, node, options) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase()) return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options)) return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options) {
  var element = options.element;
  var isBlock2 = options.isBlock;
  var isVoid2 = options.isVoid;
  var isPre = options.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element)) return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node = remove(node);
        continue;
      }
      node.data = text;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (root.ActiveXObject) useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node(node, options) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options) {
  if (node.isBlock || options.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options) {
  if (!(this instanceof TurndownService)) return new TurndownService(options);
  var defaults = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults, options);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "") return "";
    var output = process.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape) {
      return accumulator.replace(escape[0], escape[1]);
    }, string);
  }
};
function process(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node(node, self.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing) content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}

// src/constants.ts
var templatePlain = "# {{title}}\n\n## Metadata\n- **CiteKey**: {{citekey}}\n - **Type**: {{itemType}}\n - **Title**: {{title}}, \n - **Author**: {{author}};  \n- **Editor**: {{editor}};  \n- **Translator**: {{translator}}\n- **Publisher**: {{publisher}},\n- **Location**: {{place}},\n- **Series**: {{series}}\n- **Series Number**: {{seriesNumber}}\n- **Journal**: {{publicationTitle}}, \n- **Volume**: {{volume}},\n- **Issue**: {{issue}}\n- **Pages**: {{pages}}\n- **Year**: {{year}} \n- **DOI**: {{DOI}}\n- **ISSN**: {{ISSN}}\n- **ISBN**: {{ISBN}}\n\n## Abstract\n{{abstractNote}}\n## Files and Links\n- **Url**: {{url}}\n- **Uri**: {{uri}}\n- **Eprint**: {{eprint}}\n- **File**: {{file}}\n- **Local Library**: [Zotero]({{localLibraryLink}})\n\n## Tags and Collections\n- **Keywords**: {{keywordsAll}}\n- **Collections**: {{collectionsParent}}\n\n\n----\n\n## Comments\n{{UserNotes}}\n\n\n----\n\n## Extracted Annotations\n{{PDFNotes}}";
var templateAdmonition = "# {{title}}\n\n``` ad-info\ntitle: Metadata\n- **CiteKey**: {{citekey}}\n- **Type**: {{itemType}}\n- **Author**: {{author}}\n- **Editor**: {{editor}}\n- **Translator**: {{translator}}\n- **Publisher**: {{publisher}}\n- **Location**: {{place}}\n- **Series**: {{series}}\n- **Series Number**: {{seriesNumber}}\n- **Journal**: {{publicationTitle}}\n- **Volume**: {{volume}}\n- **Issue**: {{issue}}\n- **Pages**: {{pages}}\n- **Year**: {{year}} \n- **DOI**: {{DOI}}\n- **ISSN**: {{ISSN}}\n- **ISBN**: {{ISBN}}\n```\n```ad-quote\ntitle: Abstract\n{{abstractNote}}\n```\n```ad-abstract\ntitle: Files and Links\n- **Url**: {{url}}\n- **Uri**: {{uri}}\n- **Eprint**: {{eprint}}\n- **File**: {{file}}\n- **Local Library**: [Zotero]({{localLibraryLink}})\n```\n```ad-note\ntitle: Tags and Collections\n- **Keywords**: {{keywordsAll}}\n- **Collections**: {{collectionsParent}}\n```\n\n----\n\n## Comments\n{{UserNotes}}\n\n\n----\n\n## Extracted Annotations\n{{PDFNotes}}";
var DEFAULT_SETTINGS = {
  zoteroDbPath: "",
  templateContent: templatePlain,
  templateType: "Admonition",
  lastUpdateDate: /* @__PURE__ */ new Date("1995-12-17T03:24:00"),
  updateLibrary: "Only update existing notes",
  exportPath: "",
  exportTitle: "{{citeKey}}",
  missingfield: "Leave placeholder",
  saveManualEdits: "Save Entire Note",
  saveManualEditsStart: "",
  saveManualEditsEnd: "",
  isDoubleSpaced: true,
  multipleFieldsDivider: ";",
  nameFormat: "{{lastName}}, {{firstName}}",
  debugMode: false,
  missingfieldreplacement: "NA"
};
var TEMPLATE_REG = /\{\{[^}]+\}\}/g;
var TEMPLATE_BRACKET_REG = /\[\[\{\{[^}]+\}\}\]\]/g;

// src/i18n.ts
var import_obsidian = require("obsidian");
function detectLocale() {
  const locale = import_obsidian.moment.locale();
  if (locale && locale.startsWith("zh")) {
    return "zh";
  }
  return "en";
}
var en = {
  // ── Plugin title & section headings ──
  pluginTitle: "Zotero Direct",
  sectionImportLibrary: "Import Library",
  sectionExportNotes: "Export Notes",
  sectionUpdateLibrary: "Update Library",
  // ── Settings: Zotero Database ──
  zoteroDbPathName: "Zotero Database Path",
  zoteroDbPathDesc: "Absolute path to Zotero's SQLite database file (zotero.sqlite). For example: C:\\Users\\YourName\\Zotero\\zotero.sqlite",
  zoteroDbPathPlaceholder: "C:\\Users\\YourName\\Zotero\\zotero.sqlite",
  // ── Settings: Cache ──
  cacheStatusName: "Cache Status",
  cacheStatusDesc: "Click the refresh button to rebuild the cache from Zotero database. This pre-builds the cache so that subsequent imports are faster.",
  cacheRebuildTooltip: "Rebuild cache from Zotero database",
  cacheSetPathFirst: "Please set the Zotero database path first.",
  cacheRebuilding: "Rebuilding cache from Zotero database, this may take a while...",
  cacheRebuiltSuccess: (count) => `Cache rebuilt successfully: ${count} items cached.`,
  cacheRebuildFailed: "Failed to rebuild cache: ",
  cacheItemsCached: (count) => `${count} items cached`,
  cacheNone: "No cache",
  // ── Settings: Export Path ──
  exportPathName: "Export Path",
  exportPathDesc: "Add the relative path to the folder inside your vault where the notes will be exported",
  exportPathPlaceholder: "Example: folder1/folder2",
  // ── Settings: Note Title ──
  noteTitleName: "Note Title",
  noteTitleDesc: "Select the format of the title of the note. Possible values include: {{citeKey}}, {{title}}, {{author}},{{authorInitials}}, {{authorFullName}} {{year}}",
  noteTitlePlaceholder: "{{citeKey}}",
  // ── Settings: Template ──
  selectTemplateName: "Select Template",
  selectTemplateDesc: "Select one of the default templates or provide a custom one.",
  templatePlain: "Plain",
  templateAdmonition: "Admonition",
  templateCustom: "Custom Template",
  customTemplateName: "Custom Template",
  // ── Settings: Missing Fields ──
  missingFieldsName: "Missing Fields",
  missingFieldsDesc: "Fields that are present in the template but missing from the selected field.",
  missingFieldLeavePlaceholder: "Leave placeholder",
  missingFieldRemoveRow: "Remove (entire row)",
  missingFieldReplaceCustom: "Replace with custom text",
  missingFieldReplacementName: "Replacement for missing fields",
  // ── Settings: Divider ──
  multipleEntriesDividerName: "Multiple Entries Divider",
  multipleEntriesDividerDesc: "Type the character or expression that should separate multiple values when found in the same field (e.g. authors, editors, tags, collections).",
  // ── Settings: Name Format ──
  formatNamesName: "Format Names",
  formatNamesDesc: "Specify how the names of the authors/editors should be exported. Accepted values are {{firstName}}, {{lastName}} and {{firstNameInitials}}",
  // ── Settings: Save Manual Edits ──
  saveManualEditsName: "Save Manual Edits",
  saveManualEditsDesc: 'Select "Yes" to preserve the manual edits made to the previously extracted note (e.g. block references, comments added manually, fixed typos) when this is updated. Select "No" to overwrite any manual change to the extracted annotation when this is updated.',
  saveEntireNote: "Save Entire Note",
  selectSection: "Select Section",
  overwriteEntireNote: "Overwrite Entire Note",
  saveManualEditsStartName: "Start - Save Manual Edits",
  saveManualEditsStartDesc: "Define string (e.g. '## Notes') in the template starting from where updating the note will not overwrite the existing text. If field is left empty, the value will be set to the beginning of the note",
  saveManualEditsEndName: "End - Save Manual Edits",
  saveManualEditsEndDesc: "Define string (e.g. '## Notes') in the template until where updating the note will not overwrite the existing text. If field is left empty, the value will be set to the end of the note",
  // ── Settings: Update Library ──
  updateExistingAllName: "Update Existing/All Notes",
  updateExistingAllDesc: "Select whether to create new notes that are missing from Obsidian but present/modified within Zotero when running the Update Library command",
  onlyUpdateExisting: "Only update existing notes",
  createNewWhenMissing: "Create new notes when missing",
  // ── Commands ──
  cmdCreateUpdateNote: "Create/Update Literature Note",
  cmdUpdateLibrary: "Update Library",
  cmdUpdateCurrentNote: "Update Current Note",
  // ── Notices ──
  noticeImported: (citeKey) => `Imported ${citeKey}!`,
  noticeDbNotConfigured: "Zotero database path not configured. Please set it in plugin settings.",
  noticeDbReadFailed: "Failed to read Zotero database: ",
  noticeUpdatedEntries: (count) => `Updated ${count} entries`,
  noticeCurrentNoteUpdated: (name) => `Current Note ${name} updated`,
  noticeCurrentNoteNotFound: (name) => `Current Note ${name} not found in the library`,
  noticeCiteKeyNotFound: (name) => `Cannot find citeKey from Current Note: ${name}`,
  // ── Modal ──
  labelTags: "Tags: ",
  noSearchResult: "No search result"
};
var zh = {
  // ── 插件标题和分区标题 ──
  pluginTitle: "Zotero Direct \u6587\u732E\u5BFC\u5165\u5DE5\u5177",
  sectionImportLibrary: "\u5BFC\u5165\u6587\u732E\u5E93",
  sectionExportNotes: "\u5BFC\u51FA\u7B14\u8BB0",
  sectionUpdateLibrary: "\u66F4\u65B0\u6587\u732E\u5E93",
  // ── 设置：Zotero 数据库 ──
  zoteroDbPathName: "Zotero \u6570\u636E\u5E93\u8DEF\u5F84",
  zoteroDbPathDesc: "Zotero \u7684 SQLite \u6570\u636E\u5E93\u6587\u4EF6\uFF08zotero.sqlite\uFF09\u7684\u7EDD\u5BF9\u8DEF\u5F84\u3002\u4F8B\u5982\uFF1AC:\\Users\\\u7528\u6237\u540D\\Zotero\\zotero.sqlite",
  zoteroDbPathPlaceholder: "C:\\Users\\\u7528\u6237\u540D\\Zotero\\zotero.sqlite",
  // ── 设置：缓存 ──
  cacheStatusName: "\u7F13\u5B58\u72B6\u6001",
  cacheStatusDesc: "\u70B9\u51FB\u5237\u65B0\u6309\u94AE\u4ECE Zotero \u6570\u636E\u5E93\u91CD\u5EFA\u7F13\u5B58\u3002\u9884\u5148\u6784\u5EFA\u7F13\u5B58\u53EF\u4EE5\u4F7F\u540E\u7EED\u5BFC\u5165\u66F4\u5FEB\u3002",
  cacheRebuildTooltip: "\u4ECE Zotero \u6570\u636E\u5E93\u91CD\u5EFA\u7F13\u5B58",
  cacheSetPathFirst: "\u8BF7\u5148\u8BBE\u7F6E Zotero \u6570\u636E\u5E93\u8DEF\u5F84\u3002",
  cacheRebuilding: "\u6B63\u5728\u4ECE Zotero \u6570\u636E\u5E93\u91CD\u5EFA\u7F13\u5B58\uFF0C\u8BF7\u7A0D\u5019\u2026",
  cacheRebuiltSuccess: (count) => `\u7F13\u5B58\u91CD\u5EFA\u6210\u529F\uFF1A\u5DF2\u7F13\u5B58 ${count} \u4E2A\u6761\u76EE\u3002`,
  cacheRebuildFailed: "\u7F13\u5B58\u91CD\u5EFA\u5931\u8D25\uFF1A",
  cacheItemsCached: (count) => `\u5DF2\u7F13\u5B58 ${count} \u4E2A\u6761\u76EE`,
  cacheNone: "\u65E0\u7F13\u5B58",
  // ── 设置：导出路径 ──
  exportPathName: "\u5BFC\u51FA\u8DEF\u5F84",
  exportPathDesc: "\u8BBE\u7F6E\u4ED3\u5E93\u5185\u7528\u4E8E\u5BFC\u51FA\u7B14\u8BB0\u7684\u6587\u4EF6\u5939\u7684\u76F8\u5BF9\u8DEF\u5F84",
  exportPathPlaceholder: "\u4F8B\u5982\uFF1Afolder1/folder2",
  // ── 设置：笔记标题 ──
  noteTitleName: "\u7B14\u8BB0\u6807\u9898",
  noteTitleDesc: "\u8BBE\u7F6E\u7B14\u8BB0\u6807\u9898\u7684\u683C\u5F0F\u3002\u53EF\u7528\u53D8\u91CF\u5305\u62EC\uFF1A{{citeKey}}\u3001{{title}}\u3001{{author}}\u3001{{authorInitials}}\u3001{{authorFullName}}\u3001{{year}}",
  noteTitlePlaceholder: "{{citeKey}}",
  // ── 设置：模板 ──
  selectTemplateName: "\u9009\u62E9\u6A21\u677F",
  selectTemplateDesc: "\u9009\u62E9\u4E00\u4E2A\u9ED8\u8BA4\u6A21\u677F\u6216\u63D0\u4F9B\u81EA\u5B9A\u4E49\u6A21\u677F\u3002",
  templatePlain: "\u7B80\u6D01",
  templateAdmonition: "Admonition",
  templateCustom: "\u81EA\u5B9A\u4E49\u6A21\u677F",
  customTemplateName: "\u81EA\u5B9A\u4E49\u6A21\u677F",
  // ── 设置：缺失字段 ──
  missingFieldsName: "\u7F3A\u5931\u5B57\u6BB5\u5904\u7406",
  missingFieldsDesc: "\u6A21\u677F\u4E2D\u5B58\u5728\u4F46\u6240\u9009\u6761\u76EE\u4E2D\u7F3A\u5931\u7684\u5B57\u6BB5\u7684\u5904\u7406\u65B9\u5F0F\u3002",
  missingFieldLeavePlaceholder: "\u4FDD\u7559\u5360\u4F4D\u7B26",
  missingFieldRemoveRow: "\u5220\u9664\uFF08\u6574\u884C\uFF09",
  missingFieldReplaceCustom: "\u66FF\u6362\u4E3A\u81EA\u5B9A\u4E49\u6587\u672C",
  missingFieldReplacementName: "\u7F3A\u5931\u5B57\u6BB5\u7684\u66FF\u6362\u6587\u672C",
  // ── 设置：分隔符 ──
  multipleEntriesDividerName: "\u591A\u503C\u5206\u9694\u7B26",
  multipleEntriesDividerDesc: "\u8F93\u5165\u540C\u4E00\u5B57\u6BB5\u4E2D\u591A\u4E2A\u503C\uFF08\u5982\u4F5C\u8005\u3001\u7F16\u8F91\u3001\u6807\u7B7E\u3001\u5408\u96C6\uFF09\u4E4B\u95F4\u7684\u5206\u9694\u5B57\u7B26\u6216\u8868\u8FBE\u5F0F\u3002",
  // ── 设置：姓名格式 ──
  formatNamesName: "\u59D3\u540D\u683C\u5F0F",
  formatNamesDesc: "\u6307\u5B9A\u4F5C\u8005/\u7F16\u8F91\u59D3\u540D\u7684\u5BFC\u51FA\u683C\u5F0F\u3002\u53EF\u7528\u53D8\u91CF\uFF1A{{firstName}}\u3001{{lastName}}\u3001{{firstNameInitials}}",
  // ── 设置：保留手动编辑 ──
  saveManualEditsName: "\u4FDD\u7559\u624B\u52A8\u7F16\u8F91",
  saveManualEditsDesc: '\u9009\u62E9"\u4FDD\u7559\u6574\u7BC7\u7B14\u8BB0"\u4EE5\u5728\u66F4\u65B0\u65F6\u4FDD\u7559\u4E4B\u524D\u5BF9\u7B14\u8BB0\u7684\u624B\u52A8\u4FEE\u6539\uFF08\u5982\u5757\u5F15\u7528\u3001\u624B\u52A8\u6DFB\u52A0\u7684\u8BC4\u8BBA\u3001\u4FEE\u6B63\u7684\u9519\u522B\u5B57\uFF09\u3002\u9009\u62E9"\u8986\u76D6\u6574\u7BC7\u7B14\u8BB0"\u4EE5\u5728\u66F4\u65B0\u65F6\u8986\u76D6\u6240\u6709\u624B\u52A8\u4FEE\u6539\u3002',
  saveEntireNote: "\u4FDD\u7559\u6574\u7BC7\u7B14\u8BB0",
  selectSection: "\u9009\u62E9\u4FDD\u7559\u533A\u57DF",
  overwriteEntireNote: "\u8986\u76D6\u6574\u7BC7\u7B14\u8BB0",
  saveManualEditsStartName: "\u4FDD\u7559\u533A\u57DF - \u8D77\u59CB\u4F4D\u7F6E",
  saveManualEditsStartDesc: "\u5B9A\u4E49\u6A21\u677F\u4E2D\u7684\u5B57\u7B26\u4E32\uFF08\u5982 '## \u7B14\u8BB0'\uFF09\uFF0C\u4ECE\u8BE5\u4F4D\u7F6E\u5F00\u59CB\u7684\u5185\u5BB9\u5728\u66F4\u65B0\u65F6\u4E0D\u4F1A\u88AB\u8986\u76D6\u3002\u7559\u7A7A\u5219\u9ED8\u8BA4\u4E3A\u7B14\u8BB0\u5F00\u5934\u3002",
  saveManualEditsEndName: "\u4FDD\u7559\u533A\u57DF - \u7ED3\u675F\u4F4D\u7F6E",
  saveManualEditsEndDesc: "\u5B9A\u4E49\u6A21\u677F\u4E2D\u7684\u5B57\u7B26\u4E32\uFF08\u5982 '## \u7B14\u8BB0'\uFF09\uFF0C\u5230\u8BE5\u4F4D\u7F6E\u4E3A\u6B62\u7684\u5185\u5BB9\u5728\u66F4\u65B0\u65F6\u4E0D\u4F1A\u88AB\u8986\u76D6\u3002\u7559\u7A7A\u5219\u9ED8\u8BA4\u4E3A\u7B14\u8BB0\u672B\u5C3E\u3002",
  // ── 设置：更新文献库 ──
  updateExistingAllName: "\u66F4\u65B0\u73B0\u6709/\u6240\u6709\u7B14\u8BB0",
  updateExistingAllDesc: '\u9009\u62E9\u5728\u6267\u884C"\u66F4\u65B0\u6587\u732E\u5E93"\u547D\u4EE4\u65F6\uFF0C\u662F\u5426\u4E3A Zotero \u4E2D\u5B58\u5728\u4F46 Obsidian \u4E2D\u7F3A\u5931\u7684\u6761\u76EE\u521B\u5EFA\u65B0\u7B14\u8BB0',
  onlyUpdateExisting: "\u4EC5\u66F4\u65B0\u5DF2\u6709\u7B14\u8BB0",
  createNewWhenMissing: "\u7F3A\u5931\u65F6\u521B\u5EFA\u65B0\u7B14\u8BB0",
  // ── 命令 ──
  cmdCreateUpdateNote: "\u521B\u5EFA/\u66F4\u65B0\u6587\u732E\u7B14\u8BB0",
  cmdUpdateLibrary: "\u66F4\u65B0\u6587\u732E\u5E93",
  cmdUpdateCurrentNote: "\u66F4\u65B0\u5F53\u524D\u7B14\u8BB0",
  // ── 通知 ──
  noticeImported: (citeKey) => `\u5DF2\u5BFC\u5165 ${citeKey}\uFF01`,
  noticeDbNotConfigured: "\u672A\u914D\u7F6E Zotero \u6570\u636E\u5E93\u8DEF\u5F84\uFF0C\u8BF7\u5728\u63D2\u4EF6\u8BBE\u7F6E\u4E2D\u8FDB\u884C\u8BBE\u7F6E\u3002",
  noticeDbReadFailed: "\u8BFB\u53D6 Zotero \u6570\u636E\u5E93\u5931\u8D25\uFF1A",
  noticeUpdatedEntries: (count) => `\u5DF2\u66F4\u65B0 ${count} \u4E2A\u6761\u76EE`,
  noticeCurrentNoteUpdated: (name) => `\u5F53\u524D\u7B14\u8BB0 ${name} \u5DF2\u66F4\u65B0`,
  noticeCurrentNoteNotFound: (name) => `\u5F53\u524D\u7B14\u8BB0 ${name} \u672A\u5728\u6587\u732E\u5E93\u4E2D\u627E\u5230`,
  noticeCiteKeyNotFound: (name) => `\u65E0\u6CD5\u4ECE\u5F53\u524D\u7B14\u8BB0\u8BC6\u522B citeKey\uFF1A${name}`,
  // ── 模态框 ──
  labelTags: "\u6807\u7B7E\uFF1A",
  noSearchResult: "\u672A\u627E\u5230\u76F8\u5173\u7ED3\u679C"
};
var locales = { en, zh };
var _t = null;
function t() {
  if (!_t) {
    _t = locales[detectLocale()];
  }
  return _t;
}

// src/modal.ts
var import_obsidian4 = require("obsidian");

// src/utils.ts
var import_obsidian2 = require("obsidian");
function replaceAllTemplates(entriesArray, note, selectedEntry) {
  let copy = note.slice();
  for (let z = 0; z < entriesArray.length; z++) {
    const KW = entriesArray[z];
    const KW_Brackets = "{{" + KW + "}}";
    copy = replaceTemplate(
      copy,
      KW_Brackets,
      `${selectedEntry[KW]}`
    );
  }
  return copy;
}
function escapeRegExp(stringAdd) {
  return stringAdd.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
function replaceTemplate(stringAdd, find, replace) {
  return stringAdd.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
var makeWiki = (str) => "[[" + str + "]]";
var makeQuotes = (str) => '"' + str + '"';
var makeTags = (str) => "#" + str;
var createAuthorKey = (creators) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const authorKey = [];
  const editorKey = [];
  let authorKeyFixed = "";
  let editorKeyFixed = "";
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    if (!creator) continue;
    if (creator.creatorType === "author") {
      if (creator.name) {
        authorKey.push(creator.name);
      } else if (creator.lastName && creator.firstName) {
        authorKey.push(creator.lastName);
      } else if (creator.lastName && !creator.firstName) {
        authorKey.push(creator.lastName);
      } else if (!creator.lastName && creator.firstName) {
        authorKey.push(creator.firstName);
      }
    } else if (creator.creatorType === "editor") {
      if (creator.name) {
        editorKey.push(creator.name);
      } else if (creator.lastName && creator.firstName) {
        editorKey.push(creator.lastName);
      } else if (creator.lastName && !creator.firstName) {
        editorKey.push(creator.lastName);
      } else if (!creator.lastName && creator.firstName) {
        editorKey.push(creator.firstName);
      }
    }
  }
  if (authorKey.length == 1) {
    authorKeyFixed = (_a = authorKey[0]) != null ? _a : "";
  }
  if (authorKey.length == 2) {
    authorKeyFixed = ((_b = authorKey[0]) != null ? _b : "") + " and " + ((_c = authorKey[1]) != null ? _c : "");
  }
  if (authorKey.length == 3) {
    authorKeyFixed = ((_d = authorKey[0]) != null ? _d : "") + ", " + ((_e = authorKey[1]) != null ? _e : "") + " and " + ((_f = authorKey[2]) != null ? _f : "");
  }
  if (authorKey.length > 3) {
    authorKeyFixed = ((_g = authorKey[0]) != null ? _g : "") + " et al.";
  }
  if (authorKey.length > 0) {
    return authorKeyFixed;
  }
  if (editorKey.length == 1) {
    editorKeyFixed = (_h = editorKey[0]) != null ? _h : "";
  }
  if (editorKey.length == 2) {
    editorKeyFixed = ((_i = editorKey[0]) != null ? _i : "") + " and " + ((_j = editorKey[1]) != null ? _j : "");
  }
  if (editorKey.length == 3) {
    editorKeyFixed = ((_k = editorKey[0]) != null ? _k : "") + ", " + ((_l = editorKey[1]) != null ? _l : "") + " and " + ((_m = editorKey[2]) != null ? _m : "");
  }
  if (editorKey.length > 3) {
    editorKeyFixed = ((_n = editorKey[0]) != null ? _n : "") + " et al.";
  }
  if (editorKey.length > 0) {
    return editorKeyFixed;
  }
  return "";
};
var createAuthorKeyFullName = (creators) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const authorKey = [];
  const authorKeyReverse = [];
  const editorKey = [];
  const editorKeyReverse = [];
  let authorKeyFixed = "";
  let editorKeyFixed = "";
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    if (!creator) continue;
    if (creator.creatorType === "author") {
      if (creator.name) {
        authorKey.push(creator.name);
      } else if (creator.lastName && creator.firstName) {
        authorKey.push(creator.lastName + ", " + creator.firstName);
        authorKeyReverse.push(creator.firstName + " " + creator.lastName);
      } else if (creator.lastName && !creator.firstName) {
        authorKey.push(creator.lastName);
      } else if (!creator.lastName && creator.firstName) {
        authorKey.push(creator.firstName);
      }
    } else if (creator.creatorType === "editor") {
      if (creator.name) {
        editorKey.push(creator.name);
      } else if (creator.lastName && creator.firstName) {
        editorKey.push(creator.lastName + ", " + creator.firstName);
        editorKeyReverse.push(creator.firstName + " " + creator.lastName);
      } else if (creator.lastName && !creator.firstName) {
        editorKey.push(creator.lastName);
      } else if (!creator.lastName && creator.firstName) {
        editorKey.push(creator.firstName);
      }
    }
  }
  if (authorKey.length == 1) {
    authorKeyFixed = (_a = authorKey[0]) != null ? _a : "";
  }
  if (authorKey.length == 2) {
    authorKeyFixed = ((_b = authorKey[0]) != null ? _b : "") + " and " + ((_c = authorKeyReverse[1]) != null ? _c : "");
  }
  if (authorKey.length == 3) {
    authorKeyFixed = ((_d = authorKey[0]) != null ? _d : "") + ", " + ((_e = authorKeyReverse[1]) != null ? _e : "") + " and " + ((_f = authorKeyReverse[2]) != null ? _f : "");
  }
  if (authorKey.length > 3) {
    authorKeyFixed = ((_g = authorKey[0]) != null ? _g : "") + " et al.";
  }
  if (authorKey.length > 0) {
    return authorKeyFixed;
  }
  if (editorKey.length == 1) {
    editorKeyFixed = (_h = editorKey[0]) != null ? _h : "";
  }
  if (editorKey.length == 2) {
    editorKeyFixed = ((_i = editorKey[0]) != null ? _i : "") + " and " + ((_j = editorKeyReverse[1]) != null ? _j : "");
  }
  if (editorKey.length == 3) {
    editorKeyFixed = ((_k = editorKey[0]) != null ? _k : "") + ", " + ((_l = editorKeyReverse[1]) != null ? _l : "") + " and " + ((_m = editorKeyReverse[2]) != null ? _m : "");
  }
  if (editorKey.length > 3) {
    editorKeyFixed = ((_n = editorKey[0]) != null ? _n : "") + " et al.";
  }
  if (editorKey.length > 0) {
    return editorKeyFixed;
  }
  return "";
};
var createAuthorKeyInitials = (creators) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const authorKey = [];
  const editorKey = [];
  let authorKeyFixed = "";
  let editorKeyFixed = "";
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    if (!creator) continue;
    if (creator.creatorType === "author") {
      if (creator.name) {
        authorKey.push(creator.name);
      } else if (creator.lastName && creator.firstName) {
        authorKey.push(creator.lastName + ", " + creator.firstName.substring(0, 1) + ".");
      } else if (creator.lastName && !creator.firstName) {
        authorKey.push(creator.lastName);
      } else if (!creator.lastName && creator.firstName) {
        authorKey.push(creator.firstName);
      }
    } else if (creator.creatorType === "editor") {
      if (creator.name) {
        editorKey.push(creator.name);
      } else if (creator.lastName && creator.firstName) {
        editorKey.push(creator.lastName + ", " + creator.firstName.substring(0, 1) + ".");
      } else if (creator.lastName && !creator.firstName) {
        editorKey.push(creator.lastName);
      } else if (!creator.lastName && creator.firstName) {
        editorKey.push(creator.firstName);
      }
    }
  }
  if (authorKey.length == 1) {
    authorKeyFixed = (_a = authorKey[0]) != null ? _a : "";
  }
  if (authorKey.length == 2) {
    authorKeyFixed = ((_b = authorKey[0]) != null ? _b : "") + " and " + ((_c = authorKey[1]) != null ? _c : "");
  }
  if (authorKey.length == 3) {
    authorKeyFixed = ((_d = authorKey[0]) != null ? _d : "") + ", " + ((_e = authorKey[1]) != null ? _e : "") + " and " + ((_f = authorKey[2]) != null ? _f : "");
  }
  if (authorKey.length > 3) {
    authorKeyFixed = ((_g = authorKey[0]) != null ? _g : "") + " et al.";
  }
  if (authorKey.length > 0) {
    return authorKeyFixed;
  }
  if (editorKey.length == 1) {
    editorKeyFixed = (_h = editorKey[0]) != null ? _h : "";
  }
  if (editorKey.length == 2) {
    editorKeyFixed = ((_i = editorKey[0]) != null ? _i : "") + " and " + ((_j = editorKey[1]) != null ? _j : "");
  }
  if (editorKey.length == 3) {
    editorKeyFixed = ((_k = editorKey[0]) != null ? _k : "") + ", " + ((_l = editorKey[1]) != null ? _l : "") + " and " + ((_m = editorKey[2]) != null ? _m : "");
  }
  if (editorKey.length > 3) {
    editorKeyFixed = ((_n = editorKey[0]) != null ? _n : "") + " et al.";
  }
  if (editorKey.length > 0) {
    return editorKeyFixed;
  }
  return "";
};
function orderByDateModified(a, b) {
  if (a.dateModified > b.dateModified) {
    return -1;
  }
  if (a.dateModified < b.dateModified) {
    return 1;
  }
  return 0;
}
function formatCreatorsName(creator, nameCustom) {
  if (creator.name) {
    nameCustom = creator.name;
    nameCustom = nameCustom.trim();
    return nameCustom;
  } else if (creator.lastName && creator.firstName) {
    nameCustom = nameCustom.replace("{{lastName}}", creator.lastName);
    nameCustom = nameCustom.replace("{{firstName}}", creator.firstName);
    const getInitials = function(string) {
      var _a, _b;
      const names = string.split(" ");
      let initials = ((_a = names[0]) != null ? _a : "").substring(0, 1).toUpperCase() + ".";
      if (names.length > 1) {
        initials += ((_b = names[names.length - 1]) != null ? _b : "").substring(0, 1).toUpperCase() + ".";
      }
      return initials;
    };
    nameCustom = nameCustom.replace("{{firstNameInitials}}", getInitials(creator.firstName));
    nameCustom = nameCustom.trim();
    return nameCustom;
  } else if (creator.lastName && !creator.firstName) {
    nameCustom = nameCustom.replace("{{lastName}}", creator.lastName);
    nameCustom = nameCustom.replace("; {{firstName}}", creator.firstName);
    nameCustom = nameCustom.replace(", {{firstName}}", creator.firstName);
    nameCustom = nameCustom.replace("{{firstName}}", "");
    nameCustom = nameCustom.trim();
    return nameCustom;
  } else if (!creator.lastName && creator.firstName) {
    nameCustom = nameCustom.replace("; {{lastName}}", creator.firstName);
    nameCustom = nameCustom.replace(", {{lastName}}", creator.firstName);
    nameCustom = nameCustom.replace("{{lastName}}", "");
    nameCustom = nameCustom.replace("{{firstName}}", creator.firstName);
    nameCustom = nameCustom.trim();
    return nameCustom;
  }
  return nameCustom;
}
var createCreatorList = (creators, typeCreator, note, divider, nameFormat) => {
  const creatorList = [];
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    if (!creator) continue;
    if (creator.creatorType === typeCreator) {
      creatorList.push(formatCreatorsName(creator, nameFormat));
    }
  }
  const creatorListBracket = creatorList.map(makeWiki);
  const creatorListQuotes = creatorList.map(makeQuotes);
  if (divider.slice(-1) !== " ") {
    divider = divider + " ";
  }
  if (creatorList.length == 0) {
    return note;
  } else {
    note = replaceTemplate(
      note,
      `[[{{${typeCreator}}}]]`,
      creatorListBracket.join(divider)
    );
    note = replaceTemplate(
      note,
      `"{{${typeCreator}}}"`,
      creatorListQuotes.join(divider)
    );
    note = replaceTemplate(
      note,
      `{{${typeCreator}}}`,
      creatorList.join(divider)
    );
    return note;
  }
};
var createCreatorAllList = (creators, note, divider, nameFormat) => {
  const creatorList = [];
  for (let creatorindex = 0; creatorindex < creators.length; creatorindex++) {
    const creator = creators[creatorindex];
    if (!creator) continue;
    creatorList.push(formatCreatorsName(creator, nameFormat));
  }
  const creatorListBracket = creatorList.map(makeWiki);
  const creatorListQuotes = creatorList.map(makeQuotes);
  if (divider.slice(-1) !== " ") {
    divider = divider + " ";
  }
  if (creatorList.length == 0) {
    return note;
  } else {
    note = replaceTemplate(
      note,
      `[[{{creator}}]]`,
      creatorListBracket.join(divider)
    );
    note = replaceTemplate(
      note,
      `"{{creator}}"`,
      creatorListQuotes.join(divider)
    );
    note = replaceTemplate(note, `{{creator}}`, creatorList.join(divider));
    note = replaceTemplate(note, `{{Creator}}`, creatorList.join(divider));
    return note;
  }
};
function replaceMissingFields(note, missingfield, missingfieldreplacement) {
  var _a;
  let copy = note.slice();
  if (missingfield === "Replace with custom text") {
    copy = copy.replace(TEMPLATE_BRACKET_REG, missingfieldreplacement).trim();
    copy = copy.replace(TEMPLATE_REG, missingfieldreplacement).trim();
  } else if (missingfield === "Remove (entire row)") {
    const lines = copy.split(/\r?\n/);
    for (let j = 0; j < lines.length; j++) {
      if ((_a = lines[j]) == null ? void 0 : _a.match(TEMPLATE_REG)) {
        lines.splice(j, 1);
        j--;
      }
    }
    copy = lines.join("\n");
  }
  copy = copy.replace("```ad-quote\ntitle: Abstract\n```\n", "");
  copy = copy.replace(
    "```ad-abstract\ntitle: Files and Links\n```\n",
    ""
  );
  copy = copy.replace(
    "```ad-note\ntitle: Tags and Collections\n```\n",
    ""
  );
  copy = copy.replace(
    "## Abstract\n\n## Files and Links\n",
    "## Files and Links\n"
  );
  copy = copy.replace(
    "## Files and Links\n\n## Tags and Collections\n",
    "## Tags and Collections\n"
  );
  copy = copy.replace("## Tags and Collections\n\n", "\n");
  return copy;
}
function createLocalFileLink(reference) {
  if (reference.attachments.length == 0) return "{{localFile}}";
  const filesList = [];
  for (let attachmentindex = 0; attachmentindex < reference.attachments.length; attachmentindex++) {
    const attachment = reference.attachments[attachmentindex];
    if (!attachment) continue;
    if (attachment.itemType !== "attachment")
      continue;
    if (attachment.path == void 0) {
      attachment.path = "";
    }
    const selectedfile = "[" + attachment.title + "](file:///" + // added an extra "/" to make it work on Linux
    encodeURI(attachment.path.split(" ").join(" ")) + ")";
    filesList.push(selectedfile);
  }
  const filesListString = filesList.join("; ");
  return filesListString;
}
function createLocalFilePathLink(reference) {
  if (reference.attachments.length == 0) return "{{localFilePathLink}}";
  const filesPathList = [];
  for (let attachmentindex = 0; attachmentindex < reference.attachments.length; attachmentindex++) {
    const attachment = reference.attachments[attachmentindex];
    if (!attachment) continue;
    if (attachment.itemType !== "attachment")
      continue;
    if (attachment.select == void 0) {
      attachment.select = "";
    }
    const selectedFilePath = "[" + attachment.title + "](" + encodeURI(attachment.select) + ")";
    filesPathList.push(selectedFilePath);
  }
  const filesPathListString = filesPathList.join("; ");
  return filesPathListString;
}
function createZoteroReaderPathLink(reference) {
  if (reference.attachments.length == 0) return "{{localFilePathLink}}";
  const filesPathList = [];
  for (let attachmentindex = 0; attachmentindex < reference.attachments.length; attachmentindex++) {
    const attachment = reference.attachments[attachmentindex];
    if (!attachment) continue;
    if (attachment.itemType !== "attachment")
      continue;
    if (attachment.select == void 0) {
      attachment.select = "";
    }
    const selectedFilePath = "[" + attachment.title + "](" + encodeURI(attachment.select).replace(
      "select",
      "open-pdf"
    ) + ")";
    filesPathList.push(selectedFilePath);
  }
  const filesPathListString = filesPathList.join("; ");
  return filesPathListString;
}
function createNoteTitle(selectedEntry, exportTitle, exportPath) {
  exportTitle = exportTitle.replace("{{citeKey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{citationKey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{citationkey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{citekey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{citekey}}", selectedEntry.citationKey);
  exportTitle = exportTitle.replace("{{title}}", selectedEntry.title);
  exportTitle = exportTitle.replace("{{author}}", selectedEntry.authorKey);
  exportTitle = exportTitle.replace("{{authors}}", selectedEntry.authorKey);
  exportTitle = exportTitle.replace("{{authorInitials}}", selectedEntry.authorKeyInitials);
  exportTitle = exportTitle.replace("{{authorsInitials}}", selectedEntry.authorKeyInitials);
  exportTitle = exportTitle.replace("{{authorFullName}}", selectedEntry.authorKeyFullName);
  exportTitle = exportTitle.replace("{{authorsFullName}}", selectedEntry.authorKeyFullName);
  exportTitle = exportTitle.replace("{{year}}", selectedEntry.year);
  exportTitle = exportTitle.replace("{{date}}", selectedEntry.year);
  exportTitle = exportTitle.replace(/[/\\?%*:|"<>]/g, "");
  return (0, import_obsidian2.normalizePath)(exportPath + "/" + exportTitle + ".md");
}
function replaceTagList(selectedEntry, arrayExtractedKeywords, metadata, divider) {
  selectedEntry.zoteroTags = [];
  if (selectedEntry.tags.length > 0) {
    for (let indexTag = 0; indexTag < selectedEntry.tags.length; indexTag++) {
      const tagEntry = selectedEntry.tags[indexTag];
      if (tagEntry) {
        selectedEntry.zoteroTags.push(tagEntry.tag);
      }
    }
  }
  if (divider.slice(-1) !== " ") {
    divider = divider + " ";
  }
  const tagsZotero = selectedEntry.zoteroTags.sort();
  const tagsPDF = arrayExtractedKeywords.sort();
  const tagsCombined = tagsZotero.concat(tagsPDF).sort();
  if (tagsZotero.length > 0) {
    const tagsZoteroBracket = tagsZotero.map(makeWiki);
    metadata = replaceTemplate(
      metadata,
      `[[{{keywordsZotero}}]]`,
      String(tagsZoteroBracket.join(divider))
    );
    const tagsZoteroQuotes = tagsZotero.map(makeQuotes);
    metadata = replaceTemplate(
      metadata,
      `"{{keywordsZotero}}"`,
      String(tagsZoteroQuotes.join(divider))
    );
    const tagsZoteroTags = tagsZotero.map(makeTags);
    metadata = replaceTemplate(
      metadata,
      `#{{keywordsZotero}}`,
      String(tagsZoteroTags.join(divider))
    );
    metadata = replaceTemplate(
      metadata,
      `{{keywordsZotero}}`,
      String(tagsZotero.join(divider))
    );
  }
  if (tagsPDF.length > 0) {
    const tagsPDFBracket = tagsPDF.map(makeWiki);
    metadata = replaceTemplate(
      metadata,
      `[[{{keywordsPDF}}]]`,
      String(tagsPDFBracket.join(divider))
    );
    const tagsPDFQuotes = tagsPDF.map(makeQuotes);
    metadata = replaceTemplate(
      metadata,
      `"{{keywordsPDF}}"`,
      String(tagsPDFQuotes.join(divider))
    );
    const tagsPDFTags = tagsPDF.map(makeTags);
    metadata = replaceTemplate(
      metadata,
      `#{{keywordsPDF}}`,
      String(tagsPDFTags.join(divider))
    );
    metadata = replaceTemplate(
      metadata,
      `{{keywordsPDF}}`,
      String(tagsPDF.join(divider))
    );
  }
  if (tagsCombined.length > 0) {
    const tagsCombinedBracket = tagsCombined.map(makeWiki);
    metadata = replaceTemplate(
      metadata,
      `[[{{keywords}}]]`,
      String(tagsCombinedBracket.join(divider))
    );
    metadata = replaceTemplate(
      metadata,
      `[[{{keywordsAll}}]]`,
      String(tagsCombinedBracket.join(divider))
    );
    const tagsCombinedQuotes = tagsCombined.map(makeQuotes);
    metadata = replaceTemplate(
      metadata,
      `"{{keywordsAll}}"`,
      String(tagsCombinedQuotes.join(divider))
    );
    metadata = replaceTemplate(
      metadata,
      `"{{keywords}}"`,
      String(tagsCombinedQuotes.join(divider))
    );
    const tagsCombinedTags = tagsCombined.map(makeTags);
    metadata = replaceTemplate(
      metadata,
      `#{{keywordsAll}}`,
      String(tagsCombinedTags.join(divider))
    );
    metadata = replaceTemplate(
      metadata,
      `#{{keywords}}`,
      String(tagsCombinedTags.join(divider))
    );
    metadata = replaceTemplate(
      metadata,
      `{{keywordsAll}}`,
      String(tagsCombined.join(divider))
    );
    metadata = replaceTemplate(
      metadata,
      `{{keywords}}`,
      String(tagsCombined.join(divider))
    );
  }
  if (selectedEntry.zoteroTags.length == 0) {
    metadata = metadata.replace("# Tags\n", "");
    metadata = metadata.replace("## Tags\n", "");
    metadata = metadata.replace("### Tags\n", "");
  }
  return metadata;
}
function openSelectedNote(app, selectedEntry, exportTitle, exportPath) {
  const noteTitle = createNoteTitle(
    selectedEntry,
    exportTitle,
    exportPath
  );
  app.workspace.openLinkText(noteTitle, "", true);
}
function parseCiteKeyFromNoteName(noteName, format) {
  var _a, _b;
  const match = format.match("{{citeKey}}");
  if (match != null) {
    const idx = (_a = match.index) != null ? _a : 0;
    const regExp = format.substring(
      idx != 0 ? idx - 1 : idx,
      idx + match[0].length + 1
    ).replace("{{citeKey}}", "(s*[a-zA-Z0-9]+s*)");
    return (_b = noteName.match(regExp)) == null ? void 0 : _b[1];
  }
  return void 0;
}

// src/modal.ts
init_zotero_db();
init_zotero_cache();
var _SelectReferenceModal = class _SelectReferenceModal extends import_obsidian4.SuggestModal {
  constructor(app, plugin) {
    super(app);
    // Store current query for highlight rendering
    this.currentQuery = "";
    // Pre-computed search index for fast matching
    this.searchIndex = [];
    // Search results cache and debounce for non-blocking UX
    this.searchCache = [];
    this.lastSearchQuery = "";
    this.searchDebounceTimer = null;
    this.lastSearchSet = null;
    this.plugin = plugin;
    this.emptyStateText = t().noSearchResult;
  }
  // Function used to move the cursor in the search bar when the modal is launched
  focusInput() {
    document.getElementsByClassName("prompt-input")[0].focus();
  }
  onOpen() {
    return __async(this, null, function* () {
      var _a, _b;
      if (import_obsidian4.Platform.isDesktopApp) {
        this.focusInput();
      }
      const dbPath = this.plugin.settings.zoteroDbPath;
      if (!dbPath) {
        new import_obsidian4.Notice(t().noticeDbNotConfigured);
        return;
      }
      const cacheManager2 = getCacheManager(this.app, dbPath);
      yield cacheManager2.loadCache();
      let data;
      let cachedItems = [];
      try {
        const hasChanges = yield cacheManager2.hasDbChanged();
        if (!hasChanges && cacheManager2.getCache()) {
          const cache = cacheManager2.getCache();
          cachedItems = cache.items;
          data = { items: cachedItems, collections: cache.collections };
          if (this.plugin.settings.debugMode) console.log("[BibNotes] Using cached data:", cachedItems.length, "items");
        } else {
          const cache = cacheManager2.getCache();
          const adapter = this.app.vault.adapter;
          const vaultBasePath = adapter instanceof import_obsidian4.FileSystemAdapter ? adapter.getBasePath() : "";
          const pluginDir = vaultBasePath && this.plugin.manifest.dir ? vaultBasePath + "/" + this.plugin.manifest.dir : this.plugin.manifest.dir || "";
          if (cache && cache.dbLastModified > 0) {
            const update = yield readZoteroDatabaseIncremental(dbPath, cache.dbLastModified, {}, pluginDir);
            if (update && update.items.length > 0) {
              cacheManager2.updateCache(
                update.items,
                update.collections,
                update.updatedItemKeys
              );
              yield cacheManager2.saveCache();
              cachedItems = cacheManager2.getCache().items;
              data = { items: cachedItems, collections: update.collections };
              if (this.plugin.settings.debugMode) console.log("[BibNotes] Incremental update:", update.items.length, "items updated");
            } else {
              data = yield readZoteroDatabase(dbPath, pluginDir);
              cacheManager2.updateCache(data.items, data.collections);
              yield cacheManager2.saveCache();
              cachedItems = data.items;
              if (this.plugin.settings.debugMode) console.log("[BibNotes] Full refresh:", data.items.length, "items");
            }
          } else {
            data = yield readZoteroDatabase(dbPath, pluginDir);
            cacheManager2.updateCache(data.items, data.collections);
            yield cacheManager2.saveCache();
            cachedItems = data.items;
            if (this.plugin.settings.debugMode) console.log("[BibNotes] Initial cache:", data.items.length, "items");
          }
        }
      } catch (e) {
        new import_obsidian4.Notice(t().noticeDbReadFailed + e.message);
        console.error(e);
        return;
      }
      const bibtexArray = [];
      for (let index = 0; index < data.items.length; index++) {
        const selectedEntry = data.items[index];
        if (!selectedEntry) continue;
        const bibtexArrayItem = {};
        if (selectedEntry.hasOwnProperty("citationKey") == false) continue;
        bibtexArrayItem.citationKey = selectedEntry.citationKey;
        bibtexArrayItem.title = selectedEntry.title;
        bibtexArrayItem.date = selectedEntry.date;
        if (selectedEntry.hasOwnProperty("date")) {
          selectedEntry.year = ((_a = selectedEntry.date.match(/\d{4}/)) == null ? void 0 : _a[0]) || "";
          bibtexArrayItem.date = selectedEntry.year;
        }
        bibtexArrayItem.authorKey = (_b = createAuthorKey(selectedEntry.creators)) != null ? _b : "";
        bibtexArrayItem.authorKeyFullName = createFullAuthorNames(selectedEntry.creators);
        bibtexArrayItem.publicationTitle = selectedEntry.publicationTitle || "";
        bibtexArrayItem.abstractNote = selectedEntry.abstractNote || "";
        bibtexArrayItem.creators = selectedEntry.creators;
        bibtexArrayItem.dateModified = selectedEntry.dateModified;
        bibtexArrayItem.inlineReference = bibtexArrayItem.authorKey + ", (" + bibtexArrayItem.date + "), " + bibtexArrayItem.title + "\n" + bibtexArrayItem.citationKey;
        bibtexArray.push(bibtexArrayItem);
      }
      bibtexArray.sort(orderByDateModified);
      this.allCitationKeys = bibtexArray.map((a) => a.citationKey);
      this.selectArray = bibtexArray;
      this.data = data;
      this.buildSearchIndex();
      requestAnimationFrame(() => {
        if (this.inputEl) {
          this.inputEl.dispatchEvent(new Event("input"));
        }
      });
    });
  }
  /**
   * Build pre-computed search index with lowercase fields.
   * Called once after data loading to avoid repeated toLowerCase() during search.
   */
  buildSearchIndex() {
    this.searchIndex = this.selectArray.map((item) => {
      var _a;
      const authorOriginal = item.authorKeyFullName || item.authorKey || "";
      const abstractOriginal = item.abstractNote || "";
      const tagsOriginal = ((_a = item.zoteroTags) == null ? void 0 : _a.join(" ")) || "";
      return {
        item,
        titleLower: (item.title || "").toLowerCase(),
        authorLower: authorOriginal.toLowerCase(),
        authorOriginal,
        journalLower: (item.publicationTitle || "").toLowerCase(),
        citeKeyLower: (item.citationKey || "").toLowerCase(),
        abstractLower: abstractOriginal.toLowerCase(),
        abstractOriginal,
        tagsLower: tagsOriginal.toLowerCase(),
        tagsOriginal
      };
    });
    this.searchCache = [];
    this.lastSearchQuery = "";
    this.lastSearchSet = null;
  }
  /**
   * Cancel any pending debounced search
   */
  cancelPendingSearch() {
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
      this.searchDebounceTimer = null;
    }
  }
  /**
   * Override getSuggestions with debounced non-blocking search.
   * Returns cached results immediately so typing is never blocked,
   * then schedules the actual search and refreshes results.
   */
  getSuggestions(query2) {
    this.currentQuery = query2;
    if (!query2 || query2.trim() === "") {
      this.cancelPendingSearch();
      this.lastSearchQuery = "";
      this.lastSearchSet = null;
      this.searchCache = this.selectArray.map((item) => ({
        reference: item,
        score: 0,
        matchInfo: { titleMatches: [], authorMatches: [], journalMatches: [], citeKeyMatches: [], abstractMatch: null, tagsMatch: null }
      }));
      return this.searchCache;
    }
    if (query2 === this.lastSearchQuery) {
      return this.searchCache;
    }
    this.cancelPendingSearch();
    const capturedQuery = query2;
    this.searchDebounceTimer = window.setTimeout(() => {
      this.searchDebounceTimer = null;
      this.searchCache = this.performSearch(capturedQuery);
      this.lastSearchQuery = capturedQuery;
      if (this.inputEl) {
        this.inputEl.dispatchEvent(new Event("input"));
      }
    }, 80);
    return this.searchCache;
  }
  /**
   * Perform the actual search with optimized scoring.
   * Uses pre-computed search index and incremental filtering.
   */
  performSearch(query2) {
    var _a;
    const lowerQuery = query2.toLowerCase().trim();
    const keywords = lowerQuery.split(/\s+/).filter((kw) => kw.length > 0);
    if (keywords.length === 0) {
      this.lastSearchSet = null;
      return this.selectArray.map((item) => ({
        reference: item,
        score: 0,
        matchInfo: { titleMatches: [], authorMatches: [], journalMatches: [], citeKeyMatches: [], abstractMatch: null, tagsMatch: null }
      }));
    }
    let searchSet;
    const prevQuery = (_a = this.lastSearchQuery) == null ? void 0 : _a.toLowerCase().trim();
    if (prevQuery && lowerQuery.startsWith(prevQuery) && this.lastSearchSet && this.lastSearchSet.length < this.searchIndex.length) {
      searchSet = this.lastSearchSet;
    } else {
      searchSet = this.searchIndex;
    }
    const scoredItems = [];
    const matchedItems = [];
    for (const si of searchSet) {
      const result = this.scoreItem(si, keywords);
      if (result.score > 0) {
        scoredItems.push({
          item: si.item,
          score: result.score,
          matchInfo: result.matchInfo
        });
        matchedItems.push(si);
      }
    }
    this.lastSearchSet = matchedItems;
    scoredItems.sort((a, b) => b.score - a.score);
    const limited = scoredItems.slice(0, _SelectReferenceModal.MAX_RESULTS);
    return limited.map(({ item, score, matchInfo }) => ({
      reference: item,
      score,
      matchInfo
    }));
  }
  /**
   * Score a single item against keywords using pre-computed lowercase fields.
   * No RegExp creation — uses manual word boundary checks for speed.
   */
  scoreItem(si, keywords) {
    let totalScore = 0;
    let matchedKeywords = 0;
    const matchInfo = {
      titleMatches: [],
      authorMatches: [],
      journalMatches: [],
      citeKeyMatches: [],
      abstractMatch: null,
      tagsMatch: null
    };
    for (const keyword of keywords) {
      let keywordScore = 0;
      let keywordMatched = false;
      let idx;
      idx = si.titleLower.indexOf(keyword);
      if (idx !== -1) {
        keywordMatched = true;
        let s = 100;
        if (this.isWordBoundaryMatch(si.titleLower, idx, keyword.length)) s *= 1.5;
        if (idx === 0) s *= 2;
        keywordScore += s;
        this.collectRanges(si.titleLower, keyword, matchInfo.titleMatches);
      }
      idx = si.authorLower.indexOf(keyword);
      if (idx !== -1) {
        keywordMatched = true;
        let s = 80;
        if (this.isWordBoundaryMatch(si.authorLower, idx, keyword.length)) s *= 1.5;
        if (idx === 0) s *= 2;
        keywordScore += s;
        this.collectRanges(si.authorLower, keyword, matchInfo.authorMatches);
      }
      idx = si.journalLower.indexOf(keyword);
      if (idx !== -1) {
        keywordMatched = true;
        let s = 60;
        if (this.isWordBoundaryMatch(si.journalLower, idx, keyword.length)) s *= 1.5;
        keywordScore += s;
        this.collectRanges(si.journalLower, keyword, matchInfo.journalMatches);
      }
      idx = si.citeKeyLower.indexOf(keyword);
      if (idx !== -1) {
        keywordMatched = true;
        let s = 50;
        if (this.isWordBoundaryMatch(si.citeKeyLower, idx, keyword.length)) s *= 1.5;
        keywordScore += s;
        this.collectRanges(si.citeKeyLower, keyword, matchInfo.citeKeyMatches);
      }
      if (si.tagsLower.length > 0) {
        idx = si.tagsLower.indexOf(keyword);
        if (idx !== -1) {
          keywordMatched = true;
          let s = 40;
          if (this.isWordBoundaryMatch(si.tagsLower, idx, keyword.length)) s *= 1.5;
          keywordScore += s;
          if (!matchInfo.tagsMatch) {
            matchInfo.tagsMatch = { text: si.tagsOriginal, index: idx, keyword };
          }
        }
      }
      if (si.abstractLower.length > 0) {
        idx = si.abstractLower.indexOf(keyword);
        if (idx !== -1) {
          keywordMatched = true;
          let s = 30;
          if (this.isWordBoundaryMatch(si.abstractLower, idx, keyword.length)) s *= 1.5;
          keywordScore += s;
          if (!matchInfo.abstractMatch) {
            matchInfo.abstractMatch = { text: si.abstractOriginal, index: idx, keyword };
          }
        }
      }
      if (keywordMatched) {
        totalScore += keywordScore;
        matchedKeywords++;
      }
    }
    if (matchedKeywords === keywords.length && keywords.length > 1) {
      totalScore *= 1.5;
    }
    return {
      score: matchedKeywords > 0 ? totalScore : 0,
      matchInfo
    };
  }
  /**
   * Collect all match ranges for highlighting
   */
  collectRanges(text, keyword, ranges) {
    let pos = 0;
    while ((pos = text.indexOf(keyword, pos)) !== -1) {
      ranges.push({ start: pos, end: pos + keyword.length });
      pos += 1;
    }
  }
  /**
   * Check if a match is at a word boundary (without creating RegExp)
   */
  isWordBoundaryMatch(text, index, length) {
    const before = index === 0 || !this.isWordChar(text.charCodeAt(index - 1));
    const after = index + length >= text.length || !this.isWordChar(text.charCodeAt(index + length));
    return before && after;
  }
  /**
   * Check if a character code is a word character (a-z, A-Z, 0-9, _)
   */
  isWordChar(code) {
    return code >= 65 && code <= 90 || // A-Z
    code >= 97 && code <= 122 || // a-z
    code >= 48 && code <= 57 || // 0-9
    code === 95;
  }
  /**
   * Custom render for suggestion items with modern UI design
   */
  renderSuggestion(item, el) {
    const reference = item.reference;
    const matchInfo = item.matchInfo;
    el.addClass("bibnotes-suggestion-item");
    const container = el.createDiv({ cls: "bibnotes-suggestion-container" });
    const titleRow = container.createDiv({ cls: "bibnotes-suggestion-title-row" });
    const titleEl = titleRow.createDiv({ cls: "bibnotes-suggestion-title" });
    if ((matchInfo == null ? void 0 : matchInfo.titleMatches) && matchInfo.titleMatches.length > 0) {
      this.renderHighlightedWithRanges(titleEl, reference.title || "Untitled", matchInfo.titleMatches);
    } else {
      titleEl.setText(reference.title || "Untitled");
    }
    const authorsRow = container.createDiv({ cls: "bibnotes-suggestion-authors-row" });
    const allAuthors = this.getAllAuthorNames(reference);
    if (allAuthors.length > 0) {
      const authorsEl = authorsRow.createSpan({ cls: "bibnotes-suggestion-authors" });
      const fullText = allAuthors.join(", ");
      const hasAuthorMatch = (matchInfo == null ? void 0 : matchInfo.authorMatches) && matchInfo.authorMatches.length > 0;
      const authorDisplayRanges = hasAuthorMatch ? this.findHighlightRanges(fullText, this.currentQuery) : [];
      if (authorDisplayRanges.length > 0) {
        this.renderHighlightedWithRanges(authorsEl, fullText, authorDisplayRanges);
      } else {
        authorsEl.setText(fullText);
      }
      if (allAuthors.length > 2) {
        const truncRanges = authorDisplayRanges.length > 0 ? authorDisplayRanges : void 0;
        requestAnimationFrame(() => {
          this.truncateAuthorsToFit(authorsEl, allAuthors, truncRanges);
        });
      }
    }
    const journalRow = container.createDiv({ cls: "bibnotes-suggestion-journal-row" });
    const journalLeft = journalRow.createDiv({ cls: "bibnotes-suggestion-journal-left" });
    const journalText = reference.publicationTitle || "";
    const yearText = reference.date || "";
    const metaText = [journalText, yearText].filter(Boolean).join(", ");
    if (metaText) {
      const journalEl = journalLeft.createSpan({ cls: "bibnotes-suggestion-journal" });
      const hasJournalMatch = (matchInfo == null ? void 0 : matchInfo.journalMatches) && matchInfo.journalMatches.length > 0;
      const journalDisplayRanges = hasJournalMatch ? this.findHighlightRanges(metaText, this.currentQuery) : [];
      if (journalDisplayRanges.length > 0) {
        this.renderHighlightedWithRanges(journalEl, metaText, journalDisplayRanges);
      } else {
        journalEl.setText(metaText);
      }
    }
    const citeKeyEl = journalRow.createDiv({ cls: "bibnotes-suggestion-citekey" });
    const fullKey = reference.citationKey;
    const TAIL = 6;
    const MAX_DISPLAY = 38;
    if (fullKey.length > MAX_DISPLAY) {
      const head = MAX_DISPLAY - 1 - TAIL;
      const truncKey = fullKey.slice(0, head) + "\u2026" + fullKey.slice(-TAIL);
      citeKeyEl.setAttribute("title", fullKey);
      if ((matchInfo == null ? void 0 : matchInfo.citeKeyMatches) && matchInfo.citeKeyMatches.length > 0) {
        const mapped = this.mapRangesToTruncated(matchInfo.citeKeyMatches, fullKey.length, head, TAIL);
        this.renderHighlightedWithRanges(citeKeyEl, truncKey, mapped);
      } else {
        citeKeyEl.setText(truncKey);
      }
    } else {
      if ((matchInfo == null ? void 0 : matchInfo.citeKeyMatches) && matchInfo.citeKeyMatches.length > 0) {
        this.renderHighlightedWithRanges(citeKeyEl, fullKey, matchInfo.citeKeyMatches);
      } else {
        citeKeyEl.setText(fullKey);
      }
    }
    if ((matchInfo == null ? void 0 : matchInfo.abstractMatch) || (matchInfo == null ? void 0 : matchInfo.tagsMatch)) {
      const contextRow = container.createDiv({ cls: "bibnotes-suggestion-context-row" });
      const contextEl = contextRow.createDiv({ cls: "bibnotes-suggestion-context" });
      if (matchInfo.abstractMatch) {
        const context = this.extractContext(matchInfo.abstractMatch.text, matchInfo.abstractMatch.index, matchInfo.abstractMatch.keyword);
        contextEl.addClass("bibnotes-context-abstract");
        this.renderHighlightedText(contextEl, context, matchInfo.abstractMatch.keyword);
      } else if (matchInfo.tagsMatch) {
        const context = this.extractContext(matchInfo.tagsMatch.text, matchInfo.tagsMatch.index, matchInfo.tagsMatch.keyword);
        contextEl.addClass("bibnotes-context-tags");
        contextEl.setText(t().labelTags + context);
      }
    }
  }
  /**
   * Extract context around a match for display
   */
  extractContext(text, index, keyword, contextChars = 50) {
    const start = Math.max(0, index - contextChars);
    const end = Math.min(text.length, index + keyword.length + contextChars);
    let context = text.substring(start, end);
    if (start > 0) context = "..." + context;
    if (end < text.length) context = context + "...";
    return context;
  }
  /**
   * Map highlight ranges from the full string to the truncated "head…tail" string.
   * Ranges entirely inside the omitted middle are dropped.
   * Ranges spanning boundaries are clamped.
   */
  mapRangesToTruncated(ranges, fullLen, head, tail) {
    const tailStart = fullLen - tail;
    const ellipsisPos = head;
    const tailOffset = ellipsisPos + 1 - tailStart;
    const mapped = [];
    for (const r of ranges) {
      if (r.start < head) {
        mapped.push({ start: r.start, end: Math.min(r.end, head) });
      }
      if (r.end > tailStart) {
        const s = Math.max(r.start, tailStart);
        mapped.push({ start: s + tailOffset, end: r.end + tailOffset });
      }
    }
    return mapped;
  }
  /**
   * Render text with pre-calculated highlight ranges
   */
  renderHighlightedWithRanges(el, text, ranges) {
    if (!ranges || ranges.length === 0) {
      el.setText(text);
      return;
    }
    const sortedRanges = [...ranges].sort((a, b) => a.start - b.start);
    const merged = [];
    for (const range of sortedRanges) {
      if (merged.length === 0) {
        merged.push(range);
      } else {
        const last = merged[merged.length - 1];
        if (range.start <= last.end) {
          last.end = Math.max(last.end, range.end);
        } else {
          merged.push(range);
        }
      }
    }
    let lastEnd = 0;
    for (const range of merged) {
      if (range.start > lastEnd) {
        el.appendText(text.substring(lastEnd, range.start));
      }
      const highlight = el.createSpan({ cls: "bibnotes-suggestion-highlight" });
      highlight.setText(text.substring(range.start, range.end));
      lastEnd = range.end;
    }
    if (lastEnd < text.length) {
      el.appendText(text.substring(lastEnd));
    }
  }
  /**
   * Get all author names as an array
   */
  getAllAuthorNames(reference) {
    var _a, _b, _c, _d, _e, _f;
    if (!reference.creators || reference.creators.length === 0) {
      const fallback = reference.authorKeyFullName || reference.authorKey || "";
      return fallback ? [fallback] : [];
    }
    const authors = [];
    for (const creator of reference.creators) {
      if (creator.creatorType === "author") {
        const firstName = (_b = (_a = creator.firstName) == null ? void 0 : _a.trim()) != null ? _b : "";
        const lastName = (_d = (_c = creator.lastName) == null ? void 0 : _c.trim()) != null ? _d : "";
        const name = (_f = (_e = creator.name) == null ? void 0 : _e.trim()) != null ? _f : "";
        if (firstName && lastName) {
          authors.push(`${firstName} ${lastName}`);
        } else if (lastName) {
          authors.push(lastName);
        } else if (firstName) {
          authors.push(firstName);
        } else if (name) {
          authors.push(name);
        }
      }
    }
    if (authors.length === 0) {
      const fallback = reference.authorKeyFullName || reference.authorKey || "";
      return fallback ? [fallback] : [];
    }
    return authors;
  }
  /**
   * Dynamically truncate authors to fit within one line.
   * Priority: 1st, last, 2nd, 2nd-to-last, 3rd, 3rd-to-last, ...
   */
  truncateAuthorsToFit(el, allAuthors, authorMatches) {
    if (allAuthors.length <= 2) return;
    if (el.scrollWidth <= el.clientWidth) return;
    const n = allAuthors.length;
    const priorityIndices = [];
    let lo = 0, hi = n - 1;
    while (lo <= hi) {
      if (lo === hi) {
        priorityIndices.push(lo);
      } else {
        priorityIndices.push(lo);
        priorityIndices.push(hi);
      }
      lo++;
      hi--;
    }
    for (let keep = n - 1; keep >= 2; keep--) {
      const kept = priorityIndices.slice(0, keep).sort((a, b) => a - b);
      const text2 = this.buildTruncatedAuthorText(allAuthors, kept);
      el.empty();
      if (authorMatches && authorMatches.length > 0) {
        this.renderHighlightedWithRanges(el, text2, this.remapAuthorHighlights(allAuthors, kept, authorMatches));
      } else {
        el.setText(text2);
      }
      if (el.scrollWidth <= el.clientWidth) return;
    }
    const minKept = [0, n - 1];
    const text = this.buildTruncatedAuthorText(allAuthors, minKept);
    el.empty();
    if (authorMatches && authorMatches.length > 0) {
      this.renderHighlightedWithRanges(el, text, this.remapAuthorHighlights(allAuthors, minKept, authorMatches));
    } else {
      el.setText(text);
    }
  }
  /**
   * Build author display text from selected indices, inserting "..." for gaps
   */
  buildTruncatedAuthorText(allAuthors, keptIndices) {
    const parts = [];
    for (let i = 0; i < keptIndices.length; i++) {
      const idx = keptIndices[i];
      parts.push(allAuthors[idx]);
      if (i < keptIndices.length - 1) {
        const nextIdx = keptIndices[i + 1];
        if (nextIdx - idx > 1) {
          parts.push("...");
        }
      }
    }
    return parts.join(", ");
  }
  /**
   * Remap highlight ranges from full author string to truncated author string
   */
  remapAuthorHighlights(allAuthors, keptIndices, originalRanges) {
    const truncatedText = this.buildTruncatedAuthorText(allAuthors, keptIndices);
    const newRanges = [];
    for (const idx of keptIndices) {
      const authorName = allAuthors[idx];
      let origPos = 0;
      for (let i = 0; i < idx; i++) {
        origPos += allAuthors[i].length + 2;
      }
      const origEnd = origPos + authorName.length;
      const truncPos = truncatedText.indexOf(authorName);
      if (truncPos === -1) continue;
      for (const range of originalRanges) {
        const overlapStart = Math.max(range.start, origPos);
        const overlapEnd = Math.min(range.end, origEnd);
        if (overlapStart < overlapEnd) {
          const offset = truncPos - origPos;
          newRanges.push({
            start: overlapStart + offset,
            end: overlapEnd + offset
          });
        }
      }
    }
    return newRanges;
  }
  /**
   * Render text with highlights for matched query parts
   * Highlights continuous sequences of 2+ characters
   */
  renderHighlightedText(el, text, query2) {
    if (!query2 || query2.trim() === "" || !text) {
      el.setText(text);
      return;
    }
    const ranges = this.findHighlightRanges(text, query2);
    if (ranges.length === 0) {
      el.setText(text);
      return;
    }
    let lastEnd = 0;
    for (const range of ranges) {
      if (range.start > lastEnd) {
        el.appendText(text.substring(lastEnd, range.start));
      }
      const highlight = el.createSpan({ cls: "bibnotes-suggestion-highlight" });
      highlight.setText(text.substring(range.start, range.end));
      lastEnd = range.end;
    }
    if (lastEnd < text.length) {
      el.appendText(text.substring(lastEnd));
    }
  }
  /**
   * Find highlight ranges in text for the given query
   * Only returns continuous sequences of 2+ characters
   */
  findHighlightRanges(text, query2) {
    const lowerText = text.toLowerCase();
    const keywords = query2.toLowerCase().trim().split(/\s+/).filter((kw) => kw.length >= 2);
    if (keywords.length === 0) return [];
    const allRanges = [];
    for (const keyword of keywords) {
      let pos = 0;
      while ((pos = lowerText.indexOf(keyword, pos)) !== -1) {
        if (keyword.length >= 2) {
          allRanges.push({ start: pos, end: pos + keyword.length });
        }
        pos += 1;
      }
    }
    allRanges.sort((a, b) => a.start - b.start);
    const merged = [];
    for (const range of allRanges) {
      if (merged.length === 0) {
        merged.push(range);
      } else {
        const last = merged[merged.length - 1];
        if (range.start <= last.end) {
          last.end = Math.max(last.end, range.end);
        } else {
          merged.push(range);
        }
      }
    }
    return merged;
  }
  // Perform action on the selected suggestion.
  onChooseSuggestion(item, _evt) {
    return __async(this, null, function* () {
      const referenceSelected = item.reference;
      const citeKeyToBeProcessed = [];
      citeKeyToBeProcessed.push(referenceSelected.citationKey);
      for (let indexNoteToBeProcessed = 0; indexNoteToBeProcessed < citeKeyToBeProcessed.length; indexNoteToBeProcessed++) {
        const indexSelectedReference = this.data.items.findIndex(
          (item2) => item2.citationKey === citeKeyToBeProcessed[indexNoteToBeProcessed]
        );
        const selectedEntry = this.data.items[indexSelectedReference];
        if (!selectedEntry) continue;
        yield this.plugin.createNote(selectedEntry, this.data);
        if (indexNoteToBeProcessed == citeKeyToBeProcessed.length - 1) {
          openSelectedNote(
            this.app,
            selectedEntry,
            this.plugin.settings.exportTitle,
            this.plugin.settings.exportPath
          );
        }
      }
    });
  }
  onClose() {
    this.cancelPendingSearch();
    this.searchIndex = [];
    this.searchCache = [];
    this.lastSearchSet = null;
  }
  // Enhanced search using cache data
  searchItems(query2) {
    const cacheManager2 = getCacheManager(this.app, this.plugin.settings.zoteroDbPath);
    return cacheManager2.searchItems(query2);
  }
};
_SelectReferenceModal.MAX_RESULTS = 50;
var SelectReferenceModal = _SelectReferenceModal;
var UpdateLibraryModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    return __async(this, null, function* () {
      this.setTitle(t().cmdUpdateLibrary);
      this.setContent("Updating...");
      if (this.plugin.settings.debugMode) console.log("[BibNotes] Updating Zotero library");
      const dbPath = this.plugin.settings.zoteroDbPath;
      if (!dbPath) {
        new import_obsidian4.Notice(t().noticeDbNotConfigured);
        return;
      }
      let data;
      const adapter = this.app.vault.adapter;
      const vaultBasePath = adapter instanceof import_obsidian4.FileSystemAdapter ? adapter.getBasePath() : "";
      const pluginDir = vaultBasePath && this.plugin.manifest.dir ? vaultBasePath + "/" + this.plugin.manifest.dir : this.plugin.manifest.dir || "";
      try {
        data = yield readZoteroDatabase(dbPath, pluginDir);
      } catch (e) {
        new import_obsidian4.Notice(t().noticeDbReadFailed + e.message);
        console.error(e);
        return;
      }
      const bibtexArray = [];
      const lastUpdate = new Date(this.plugin.settings.lastUpdateDate);
      for (let index = 0; index < data.items.length; index++) {
        const selectedEntry = data.items[index];
        if (!selectedEntry) continue;
        const bibtexArrayItem = {};
        if (selectedEntry.hasOwnProperty("citationKey") == false) continue;
        bibtexArrayItem.citationKey = selectedEntry.citationKey;
        const noteDateModifiedArray = [];
        if (selectedEntry.dateModified) {
          noteDateModifiedArray.push(selectedEntry.dateModified);
        }
        for (let noteIdx = 0; noteIdx < selectedEntry.notes.length; noteIdx++) {
          const note = selectedEntry.notes[noteIdx];
          if (note == null ? void 0 : note.dateModified) {
            noteDateModifiedArray.push(note.dateModified);
          }
        }
        noteDateModifiedArray.sort((firstElement, secondElement) => {
          if (firstElement > secondElement) return -1;
          if (firstElement < secondElement) return 1;
          return 0;
        });
        const datemodified = noteDateModifiedArray.length > 0 ? new Date(noteDateModifiedArray[0]) : /* @__PURE__ */ new Date(0);
        if (datemodified < lastUpdate) continue;
        if (this.plugin.settings.updateLibrary === "Only update existing notes" && !(yield this.app.vault.adapter.exists(
          createNoteTitle(
            selectedEntry,
            this.plugin.settings.exportTitle,
            this.plugin.settings.exportPath
          )
        )))
          continue;
        yield this.plugin.createNote(selectedEntry, data);
        bibtexArray.push(selectedEntry.citationKey);
      }
      new import_obsidian4.Notice(t().noticeUpdatedEntries(bibtexArray.length));
      this.plugin.settings.lastUpdateDate = /* @__PURE__ */ new Date();
      this.plugin.saveSettings();
      const { contentEl } = this;
      contentEl.empty();
      contentEl.createEl("p", { text: t().noticeUpdatedEntries(bibtexArray.length) });
      new import_obsidian4.Setting(contentEl).addButton(
        (btn) => btn.setButtonText("OK").setCta().onClick(() => this.close())
      );
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function createFullAuthorNames(creators) {
  var _a, _b, _c, _d, _e, _f;
  if (!creators || creators.length === 0) return "";
  const authors = [];
  for (const creator of creators) {
    if (creator.creatorType === "author") {
      const firstName = (_b = (_a = creator.firstName) == null ? void 0 : _a.trim()) != null ? _b : "";
      const lastName = (_d = (_c = creator.lastName) == null ? void 0 : _c.trim()) != null ? _d : "";
      const name = (_f = (_e = creator.name) == null ? void 0 : _e.trim()) != null ? _f : "";
      if (firstName && lastName) {
        authors.push(`${firstName} ${lastName}`);
      } else if (lastName) {
        authors.push(lastName);
      } else if (firstName) {
        authors.push(firstName);
      } else if (name) {
        authors.push(name);
      }
    }
  }
  if (authors.length === 0) return "";
  if (authors.length === 1) return authors[0];
  if (authors.length === 2) return `${authors[0]} and ${authors[1]}`;
  return `${authors[0]} et al.`;
}

// src/settings.ts
var import_obsidian7 = require("obsidian");

// src/suggesters/FolderSuggester.ts
var import_obsidian6 = require("obsidian");

// src/suggesters/suggest.ts
var import_obsidian5 = require("obsidian");
var TextInputSuggest = class extends import_obsidian5.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    return this.getItemSuggestions(inputStr);
  }
};

// src/suggesters/FolderSuggester.ts
var FolderSuggest = class extends TextInputSuggest {
  getItemSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian6.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  getSuggestions(inputStr) {
    return this.getItemSuggestions(inputStr);
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings.ts
var SettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.debouncedSave = (0, import_obsidian7.debounce)(
      () => __async(this, null, function* () {
        yield this.plugin.saveSettings();
      }),
      500,
      true
    );
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    const { settings } = plugin;
    containerEl.empty();
    const s = t();
    new import_obsidian7.Setting(containerEl).setName(s.pluginTitle).setHeading();
    new import_obsidian7.Setting(containerEl).setName(s.sectionImportLibrary).setHeading();
    new import_obsidian7.Setting(containerEl).setName(s.zoteroDbPathName).setDesc(s.zoteroDbPathDesc).addText(
      (text) => text.setPlaceholder(s.zoteroDbPathPlaceholder).setValue(settings.zoteroDbPath).onChange((value) => __async(this, null, function* () {
        settings.zoteroDbPath = value;
        this.debouncedSave();
      }))
    );
    new import_obsidian7.Setting(containerEl).setName(s.cacheStatusName).setDesc(s.cacheStatusDesc).addExtraButton((button) => {
      button.setIcon("sync").setTooltip(s.cacheRebuildTooltip).onClick(() => __async(this, null, function* () {
        if (!settings.zoteroDbPath) {
          new import_obsidian7.Notice(s.cacheSetPathFirst);
          return;
        }
        new import_obsidian7.Notice(s.cacheRebuilding);
        try {
          const { clearCacheManager: clearCacheManager2, getCacheManager: getCacheManager2 } = yield Promise.resolve().then(() => (init_zotero_cache(), zotero_cache_exports));
          const { readZoteroDatabase: readZoteroDatabase2 } = yield Promise.resolve().then(() => (init_zotero_db(), zotero_db_exports));
          clearCacheManager2();
          const cacheManager2 = getCacheManager2(this.app, settings.zoteroDbPath);
          yield cacheManager2.clearCache();
          const vaultBasePath = this.app.vault.adapter instanceof import_obsidian7.FileSystemAdapter ? this.app.vault.adapter.getBasePath() : "";
          const pluginDir = vaultBasePath && this.plugin.manifest.dir ? vaultBasePath + "/" + this.plugin.manifest.dir : this.plugin.manifest.dir || "";
          const data = yield readZoteroDatabase2(settings.zoteroDbPath, pluginDir);
          cacheManager2.updateCache(data.items, data.collections);
          yield cacheManager2.saveCache();
          new import_obsidian7.Notice(s.cacheRebuiltSuccess(data.items.length));
          this.display();
        } catch (e) {
          new import_obsidian7.Notice(s.cacheRebuildFailed + e.message);
          console.error("[BibNotes] Cache rebuild error:", e);
        }
      }));
    }).addText((text) => {
      text.setDisabled(true);
      Promise.resolve().then(() => (init_zotero_cache(), zotero_cache_exports)).then(({ getCacheManager: getCacheManager2 }) => {
        const cacheManager2 = getCacheManager2(this.app, settings.zoteroDbPath);
        const stats = cacheManager2.getCacheStats();
        if (stats.itemCount > 0) {
          text.setValue(s.cacheItemsCached(stats.itemCount));
        } else {
          text.setValue(s.cacheNone);
        }
      });
    });
    new import_obsidian7.Setting(containerEl).setName(s.sectionExportNotes).setHeading();
    new import_obsidian7.Setting(containerEl).setName(s.exportPathName).setDesc(s.exportPathDesc).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(s.exportPathPlaceholder).setValue(this.plugin.settings.exportPath).onChange((new_folder) => __async(this, null, function* () {
        settings.exportPath = new_folder;
        yield plugin.saveSettings();
      }));
    });
    new import_obsidian7.Setting(containerEl).setName(s.noteTitleName).setDesc(s.noteTitleDesc).addText(
      (text) => text.setPlaceholder(s.noteTitlePlaceholder).setValue(settings.exportTitle).onChange((value) => __async(this, null, function* () {
        settings.exportTitle = value;
        this.debouncedSave();
      }))
    );
    new import_obsidian7.Setting(containerEl).setName(s.selectTemplateName).setDesc(s.selectTemplateDesc).addDropdown((d) => {
      d.addOption("Plain", s.templatePlain);
      d.addOption("Admonition", s.templateAdmonition);
      d.addOption("Custom", s.templateCustom);
      d.setValue(settings.templateType);
      d.onChange(
        (v) => __async(this, null, function* () {
          settings.templateType = v;
          yield plugin.saveSettings();
          this.display();
        })
      );
    });
    if (settings.templateType === "Custom") {
      new import_obsidian7.Setting(containerEl).setName(s.customTemplateName).addTextArea((text) => {
        text.inputEl.rows = 10;
        text.inputEl.setCssProps({ "width": "100%" });
        text.setValue(settings.templateContent).onChange(
          (value) => __async(this, null, function* () {
            settings.templateContent = value;
            this.debouncedSave();
          })
        );
      });
    }
    new import_obsidian7.Setting(containerEl).setName(s.missingFieldsName).setDesc(s.missingFieldsDesc).addDropdown((d) => {
      d.addOption("Leave placeholder", s.missingFieldLeavePlaceholder);
      d.addOption("Remove (entire row)", s.missingFieldRemoveRow);
      d.addOption("Replace with custom text", s.missingFieldReplaceCustom);
      d.setValue(settings.missingfield);
      d.onChange(
        (v) => __async(this, null, function* () {
          settings.missingfield = v;
          yield plugin.saveSettings();
          this.display();
        })
      );
    });
    if (settings.missingfield === "Replace with custom text") {
      new import_obsidian7.Setting(containerEl).setName(s.missingFieldReplacementName).addText(
        (text) => text.setValue(settings.missingfieldreplacement).onChange((value) => __async(this, null, function* () {
          settings.missingfieldreplacement = value;
          this.debouncedSave();
        }))
      );
    }
    new import_obsidian7.Setting(containerEl).setName(s.multipleEntriesDividerName).setDesc(s.multipleEntriesDividerDesc).addTextArea(
      (text) => text.setValue(settings.multipleFieldsDivider).onChange((value) => __async(this, null, function* () {
        settings.multipleFieldsDivider = value;
        this.debouncedSave();
      }))
    );
    new import_obsidian7.Setting(containerEl).setName(s.formatNamesName).setDesc(s.formatNamesDesc).addTextArea(
      (text) => text.setValue(settings.nameFormat).onChange((value) => __async(this, null, function* () {
        settings.nameFormat = value;
        yield plugin.saveSettings();
      }))
    );
    new import_obsidian7.Setting(containerEl).setName(s.saveManualEditsName).setDesc(s.saveManualEditsDesc).addDropdown((d) => {
      d.addOption("Save Entire Note", s.saveEntireNote);
      d.addOption("Select Section", s.selectSection);
      d.addOption("Overwrite Entire Note", s.overwriteEntireNote);
      d.setValue(settings.saveManualEdits);
      d.onChange(
        (v) => __async(this, null, function* () {
          settings.saveManualEdits = v;
          yield plugin.saveSettings();
          this.display();
        })
      );
    });
    if (settings.saveManualEdits == "Select Section") {
      new import_obsidian7.Setting(containerEl).setName(s.saveManualEditsStartName).setDesc(s.saveManualEditsStartDesc).addText(
        (text) => text.setValue(settings.saveManualEditsStart).onChange((value) => __async(this, null, function* () {
          settings.saveManualEditsStart = value;
          this.debouncedSave();
        }))
      );
      if (settings.saveManualEdits) {
        new import_obsidian7.Setting(containerEl).setName(s.saveManualEditsEndName).setDesc(s.saveManualEditsEndDesc).addText(
          (text) => text.setValue(settings.saveManualEditsEnd).onChange((value) => __async(this, null, function* () {
            settings.saveManualEditsEnd = value;
            this.debouncedSave();
          }))
        );
      }
    }
    new import_obsidian7.Setting(containerEl).setName(s.sectionUpdateLibrary).setHeading();
    new import_obsidian7.Setting(containerEl).setName(s.updateExistingAllName).setDesc(s.updateExistingAllDesc).addDropdown((d) => {
      d.addOption("Only update existing notes", s.onlyUpdateExisting);
      d.addOption("Create new notes when missing", s.createNewWhenMissing);
      d.setValue(settings.updateLibrary);
      d.onChange(
        (v) => __async(this, null, function* () {
          settings.updateLibrary = v;
          yield plugin.saveSettings();
        })
      );
    });
  }
};

// src/main.ts
init_zotero_db();
var ZoteroDirectPlugin = class extends import_obsidian8.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new SettingTab(this.app, this));
      this.addCommand({
        id: "importSelectedJson-modal",
        name: t().cmdCreateUpdateNote,
        callback: () => {
          new SelectReferenceModal(this.app, this).open();
        }
      });
      this.addCommand({
        id: "updateLibrary-modal",
        name: t().cmdUpdateLibrary,
        callback: () => {
          new UpdateLibraryModal(this.app, this).open();
        }
      });
      this.addCommand({
        id: "updateCurrentNote",
        name: t().cmdUpdateCurrentNote,
        callback: () => {
          this.updateCurrentNote();
        }
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign(
        {},
        DEFAULT_SETTINGS,
        yield this.loadData()
      );
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  parseMetadata(selectedEntry, templateOriginal) {
    var _a, _b;
    const template = templateOriginal;
    let note = template;
    note = createCreatorList(
      selectedEntry.creators,
      "author",
      note,
      this.settings.multipleFieldsDivider,
      this.settings.nameFormat
    );
    note = createCreatorList(
      selectedEntry.creators,
      "editor",
      note,
      this.settings.multipleFieldsDivider,
      this.settings.nameFormat
    );
    note = createCreatorAllList(
      selectedEntry.creators,
      note,
      this.settings.multipleFieldsDivider,
      this.settings.nameFormat
    );
    if (selectedEntry.hasOwnProperty("date") && selectedEntry.date) {
      selectedEntry.year = ((_a = selectedEntry.date.match(/\d{4}/)) == null ? void 0 : _a[0]) || "";
    } else if (selectedEntry.hasOwnProperty("dateEnacted") && selectedEntry.dateEnacted) {
      selectedEntry.year = ((_b = selectedEntry.dateEnacted.match(/\d{4}/)) == null ? void 0 : _b[0]) || "";
    }
    if (selectedEntry.hasOwnProperty("select")) {
      selectedEntry.localLibrary = "[Zotero](" + selectedEntry.select + ")";
      selectedEntry.localLibraryLink = selectedEntry.select;
    }
    selectedEntry.citeKey = selectedEntry.citationKey;
    if (selectedEntry.itemType == "journalArticle") {
      selectedEntry.itemType = "Journal Article";
    }
    if (selectedEntry.itemType == "report") {
      selectedEntry.itemType = "Report";
    }
    if (selectedEntry.itemType == "bookSection") {
      selectedEntry.itemType = "Book Section";
    }
    if (selectedEntry.itemType == "newspaperArticle") {
      selectedEntry.itemType = "Newspaper Article";
    }
    if (selectedEntry.itemType == "book") {
      selectedEntry.itemType = "Book";
    }
    selectedEntry.itemType = selectedEntry.itemType.charAt(0).toUpperCase() + selectedEntry.itemType.slice(1);
    selectedEntry.citationInLine = createAuthorKey(selectedEntry.creators) + " (" + selectedEntry.year + ")";
    selectedEntry.citationInLine = selectedEntry.citationInLine.replace("()", "");
    selectedEntry.citationInLineInitials = createAuthorKeyInitials(selectedEntry.creators) + " (" + selectedEntry.year + ")";
    selectedEntry.citationInLineInitials = selectedEntry.citationInLineInitials.replace("()", "");
    selectedEntry.citationInLineFullName = createAuthorKeyFullName(selectedEntry.creators) + " (" + selectedEntry.year + ")";
    selectedEntry.citationInLineFullName = selectedEntry.citationInLineFullName.replace("()", "");
    if (selectedEntry.itemType == "Journal Article") {
      selectedEntry.citationShort = selectedEntry.citationInLine + " " + selectedEntry.title;
      selectedEntry.citationFull = selectedEntry.citationShort + ", *" + selectedEntry.publicationTitle + "*, " + selectedEntry.volume + "(" + selectedEntry.issue + "), pp. " + selectedEntry.pages + ".";
      selectedEntry.citationFull = selectedEntry.citationFull.replace("() ", "");
      selectedEntry.citationShort = selectedEntry.citationShort.replace("** ", "");
      selectedEntry.citationFull = selectedEntry.citationFull.replace("** ", "");
      selectedEntry.citationFull = selectedEntry.citationFull.replace("pp. ", "");
    }
    selectedEntry.file = createLocalFileLink(selectedEntry);
    selectedEntry.filePath = createLocalFilePathLink(selectedEntry);
    if (this.settings.debugMode) console.log("[BibNotes] filePath:", selectedEntry.filePath);
    selectedEntry.zoteroReaderLink = createZoteroReaderPathLink(selectedEntry);
    if (this.settings.debugMode) console.log("[BibNotes] zoteroReaderLink:", selectedEntry.zoteroReaderLink);
    const entriesArray = Object.keys(selectedEntry);
    note = replaceAllTemplates(entriesArray, note, selectedEntry);
    note = note.replace(new RegExp("(?<!`)`(?!`)", "g"), "'");
    note = note.replace(
      "```ad-quote\ntitle: Abstract\n```\n",
      ""
    );
    note = note.replace(
      "```ad-abstract\ntitle: Files and Links\n```\n",
      ""
    );
    note = note.replace(
      "```ad-note\ntitle: Tags and Collections\n```",
      ""
    );
    return note;
  }
  parseCollection(selectedEntry, data, metadata) {
    const exportedCollections = data.collections;
    const selectedID = selectedEntry.itemID;
    let collectionArray = [];
    const collectionParentCode = [];
    let collectionParentArray = [];
    const collectionParentParent = [];
    const collectionKeys = Object.keys(exportedCollections);
    for (let indexCollection = 0; indexCollection < collectionKeys.length; indexCollection++) {
      const key = collectionKeys[indexCollection];
      if (!key) continue;
      const col = exportedCollections[key];
      if (!col) continue;
      const collectionName = col.name;
      const collectionItem = col.items;
      const collectionParent = col.parent;
      if (collectionItem.includes(String(selectedID))) {
        collectionArray.push(collectionName);
        collectionParentCode.push(collectionParent);
      }
    }
    if (collectionParentCode.length > 0) {
      for (let indexCollection = 0; indexCollection < collectionKeys.length; indexCollection++) {
        const key = collectionKeys[indexCollection];
        if (!key) continue;
        const col = exportedCollections[key];
        if (!col) continue;
        if (collectionParentCode.includes(
          col.key
        )) {
          collectionParentArray.push(
            col.name
          );
        }
      }
    }
    if (collectionParentParent.length > 0) {
      for (let indexCollection = 0; indexCollection < collectionKeys.length; indexCollection++) {
        const key = collectionKeys[indexCollection];
        if (!key) continue;
        const col = exportedCollections[key];
        if (!col) continue;
        if (collectionParentParent.includes(
          col.key
        )) {
          collectionParentArray.push(
            col.name
          );
        }
      }
    }
    collectionParentArray = collectionParentArray.concat(collectionArray);
    collectionArray = collectionArray.sort();
    collectionParentArray = collectionParentArray.sort();
    let divider = this.settings.multipleFieldsDivider;
    if (divider.slice(-1) !== " ") {
      divider = divider + " ";
    }
    if (collectionArray.length > 0) {
      const collectionArrayBraket = collectionArray.map(makeWiki);
      metadata = replaceTemplate(
        metadata,
        `[[{{collections}}]]`,
        String(collectionArrayBraket.join(divider))
      );
      const collectionArrayQuotes = collectionArray.map(makeQuotes);
      metadata = replaceTemplate(
        metadata,
        `"{{collections}}"`,
        String(collectionArrayQuotes.join(divider))
      );
      const collectionArrayTags = collectionArray.map(makeTags);
      metadata = replaceTemplate(
        metadata,
        `#{{collections}}`,
        String(collectionArrayTags.join(divider))
      );
      metadata = replaceTemplate(
        metadata,
        `{{collections}}`,
        String(collectionArray.join(divider))
      );
    }
    if (collectionParentArray.length > 0) {
      const collectionParentArrayBraket = collectionParentArray.map(makeWiki);
      metadata = replaceTemplate(
        metadata,
        `[[{{collectionsParent}}]]`,
        String(collectionParentArrayBraket.join(divider))
      );
      const collectionParentArrayQuotes = collectionParentArray.map(makeQuotes);
      metadata = replaceTemplate(
        metadata,
        `"{{collectionsParent}}"`,
        String(collectionParentArrayQuotes.join(divider))
      );
      const collectionParentArrayTags = collectionParentArray.map(makeTags);
      metadata = replaceTemplate(
        metadata,
        `#{{collectionsParent}}`,
        String(collectionParentArrayTags.join(divider))
      );
      metadata = replaceTemplate(
        metadata,
        `{{collectionsParent}}`,
        String(collectionParentArray.join(divider))
      );
    }
    return metadata;
  }
  // Function to extract the notes added manually
  // Function to import the right template
  importTemplate() {
    let template = templatePlain;
    if (this.settings.templateType === "Plain") {
      template = templatePlain;
    } else if (this.settings.templateType === "Admonition") {
      template = templateAdmonition;
    } else if (this.settings.templateType === "Custom") {
      template = this.settings.templateContent;
    }
    return template;
  }
  compareOldNewNote(existingNote, newNote, authorKey) {
    var _a, _b;
    const newLineRegex = RegExp(/\n/gm);
    const positionNewLine = [];
    let match = void 0;
    while (match = newLineRegex.exec(existingNote)) {
      positionNewLine.push(match.index);
    }
    const positionOldNote = [0];
    const newNoteInsertText = [];
    const newNoteInsertPosition = [];
    const newNoteArray = newNote.split("\n");
    for (let indexLines = 0; indexLines < newNoteArray.length; indexLines++) {
      let segmentWhole = "";
      let segmentFirstHalf = "";
      let segmentSecondHalf = "";
      let segmentFirstQuarter = "";
      let segmentSecondQuarter = "";
      let segmentThirdQuarter = "";
      let segmentFourthQuarter = "";
      const positionArray = [-1];
      let selectedNewLine = newNoteArray[indexLines];
      if (selectedNewLine === void 0) continue;
      selectedNewLine = selectedNewLine.trim();
      selectedNewLine = selectedNewLine.replace(/^- /gm, "");
      selectedNewLine = selectedNewLine.replace(/^> /gm, "");
      selectedNewLine = selectedNewLine.replace(/^=/gm, "");
      selectedNewLine = selectedNewLine.replace(/^\**/gm, "");
      selectedNewLine = selectedNewLine.replace(/^\*/gm, "");
      selectedNewLine = selectedNewLine.replace(/^"/gm, "");
      const authorKey_Zotero = new RegExp(
        "\\(" + authorKey + ", \\d+, p. \\d+\\)$"
      );
      const authorKey_Zotfile = new RegExp(
        "\\(" + authorKey + " \\d+:\\d+\\)$"
      );
      selectedNewLine = selectedNewLine.replace(authorKey_Zotero, "");
      selectedNewLine = selectedNewLine.replace(authorKey_Zotfile, "");
      selectedNewLine = selectedNewLine.replace(/=$/gm, "");
      selectedNewLine = selectedNewLine.replace(/\**$/gm, "");
      selectedNewLine = selectedNewLine.replace(/\*$/gm, "");
      selectedNewLine = selectedNewLine.replace(/"$/gm, "");
      if (selectedNewLine == void 0) {
        continue;
      }
      const lengthExistingLine = selectedNewLine.length;
      if (lengthExistingLine === 0) {
        continue;
      }
      if (lengthExistingLine > 1 && lengthExistingLine < 30) {
        segmentWhole = selectedNewLine;
        positionArray.push(existingNote.indexOf(segmentWhole));
      } else if (lengthExistingLine >= 30 && lengthExistingLine < 150) {
        segmentFirstHalf = selectedNewLine.substring(
          0,
          lengthExistingLine / 2
        );
        positionArray.push(existingNote.indexOf(segmentFirstHalf));
        segmentSecondHalf = selectedNewLine.substring(
          lengthExistingLine / 2 + 1,
          lengthExistingLine
        );
        positionArray.push(existingNote.indexOf(segmentSecondHalf));
      } else if (lengthExistingLine >= 150) {
        segmentFirstQuarter = selectedNewLine.substring(
          0,
          lengthExistingLine / 4
        );
        positionArray.push(existingNote.indexOf(segmentFirstQuarter));
        segmentSecondQuarter = selectedNewLine.substring(
          lengthExistingLine / 4 + 1,
          lengthExistingLine / 2
        );
        positionArray.push(existingNote.indexOf(segmentSecondQuarter));
        segmentThirdQuarter = selectedNewLine.substring(
          lengthExistingLine / 2 + 1,
          3 * lengthExistingLine / 4
        );
        positionArray.push(existingNote.indexOf(segmentThirdQuarter));
        segmentFourthQuarter = selectedNewLine.substring(
          3 * lengthExistingLine / 4 + 1,
          lengthExistingLine
        );
        positionArray.push(existingNote.indexOf(segmentFourthQuarter));
      }
      if (Math.max(...positionArray) > -1) {
        const positionOldNoteMax = Math.max(...positionArray);
        positionOldNote.push(positionOldNoteMax);
      }
      if (Math.max(...positionArray) === -1) {
        const positionOldNoteMax = Math.max(...positionOldNote);
        newNoteInsertText.push((_a = newNoteArray[indexLines]) != null ? _a : "");
        newNoteInsertPosition.push(
          (_b = positionNewLine.filter((pos) => pos > positionOldNoteMax)[0]) != null ? _b : 0
        );
      }
    }
    let doubleSpaceAdd = "";
    if (this.settings.isDoubleSpaced) {
      doubleSpaceAdd = "\n";
    }
    for (let indexNoteElements = newNoteInsertText.length - 1; indexNoteElements >= 0; indexNoteElements--) {
      const insertText = newNoteInsertText[indexNoteElements];
      const insertPosition = newNoteInsertPosition[indexNoteElements];
      existingNote = existingNote.slice(0, insertPosition) + doubleSpaceAdd + "\n" + insertText + existingNote.slice(insertPosition);
    }
    if (this.settings.saveManualEdits == "Save Entire Note") {
      return existingNote;
    }
    if (this.settings.saveManualEdits == "Select Section") {
      const startSave = this.settings.saveManualEditsStart;
      const endSave = this.settings.saveManualEditsEnd;
      let startSaveOld = 0;
      if (startSave !== "") {
        startSaveOld = existingNote.indexOf(startSave);
      }
      if (startSaveOld < 0) {
        startSaveOld = 0;
      }
      let endSaveOld = existingNote.length;
      if (endSave !== "") {
        endSaveOld = existingNote.indexOf(endSave) + endSave.length;
      }
      if (endSaveOld < 0) {
        endSaveOld = existingNote.length;
      }
      const existingNotePreserved = existingNote.substring(
        startSaveOld,
        endSaveOld
      );
      let startSaveNew = 0;
      if (startSave !== "") {
        startSaveNew = newNote.indexOf(startSave);
      }
      if (startSaveNew < 0) {
        startSaveNew = 0;
      }
      let endSaveNew = newNote.length;
      if (endSave !== "") {
        endSaveNew = newNote.indexOf(endSave) + endSave.length;
      }
      if (endSaveNew < 0) {
        endSaveNew = newNote.length;
      }
      const newNotePreservedBefore = newNote.substring(0, startSaveNew);
      const newNotePreservedAfter = newNote.substring(
        endSaveNew,
        newNote.length
      );
      const newNoteCombined = newNotePreservedBefore + existingNotePreserved + newNotePreservedAfter;
      return newNoteCombined;
    }
    return existingNote;
  }
  createNote(selectedEntry, data) {
    return __async(this, null, function* () {
      var _a, _b;
      const authorKey = createAuthorKey(selectedEntry.creators);
      selectedEntry.authorKey = authorKey != null ? authorKey : "";
      selectedEntry.authorKeyInitials = (_a = createAuthorKeyInitials(selectedEntry.creators)) != null ? _a : "";
      selectedEntry.authorKeyFullName = (_b = createAuthorKeyFullName(selectedEntry.creators)) != null ? _b : "";
      const templateNote = this.importTemplate();
      if (this.settings.debugMode) console.log("[BibNotes] Template:", templateNote);
      let litnote = this.parseMetadata(selectedEntry, templateNote);
      if (this.settings.debugMode) console.log("[BibNotes] Entry:", selectedEntry);
      litnote = this.parseCollection(selectedEntry, data, litnote);
      const noteRelPath = createNoteTitle(
        selectedEntry,
        this.settings.exportTitle,
        this.settings.exportPath
      );
      litnote = replaceTagList(
        selectedEntry,
        [],
        litnote,
        this.settings.multipleFieldsDivider
      );
      const missingFieldSetting = this.settings.missingfield;
      litnote = replaceMissingFields(
        litnote,
        missingFieldSetting,
        this.settings.missingfieldreplacement
      );
      const existingFile = this.app.vault.getAbstractFileByPath(noteRelPath);
      if (this.settings.saveManualEdits !== "Overwrite Entire Note" && existingFile instanceof import_obsidian8.TFile) {
        const existingNoteAll = yield this.app.vault.read(existingFile);
        litnote = this.compareOldNewNote(
          existingNoteAll,
          litnote,
          authorKey != null ? authorKey : ""
        );
      }
      if (this.settings.debugMode) {
        console.log("[BibNotes] NoteRelPath:", noteRelPath);
        console.log("[BibNotes] Final Note:", litnote);
      }
      if (existingFile instanceof import_obsidian8.TFile) {
        yield this.app.vault.modify(existingFile, litnote);
      } else {
        const folderPath = (0, import_obsidian8.normalizePath)(this.settings.exportPath);
        if (folderPath && !(yield this.app.vault.adapter.exists(folderPath))) {
          yield this.app.vault.createFolder(folderPath);
        }
        yield this.app.vault.create(noteRelPath, litnote);
      }
      new import_obsidian8.Notice(t().noticeImported(selectedEntry.citationKey));
    });
  }
  updateCurrentNote() {
    return __async(this, null, function* () {
      if (this.settings.debugMode) console.log("[BibNotes] Updating Current Note");
      const dbPath = this.settings.zoteroDbPath;
      if (!dbPath) {
        new import_obsidian8.Notice(t().noticeDbNotConfigured);
        return;
      }
      let data;
      const vaultBasePath = this.app.vault.adapter instanceof import_obsidian8.FileSystemAdapter ? this.app.vault.adapter.getBasePath() : "";
      const pluginDir = vaultBasePath && this.manifest.dir ? vaultBasePath + "/" + this.manifest.dir : this.manifest.dir || "";
      try {
        data = yield readZoteroDatabase(dbPath, pluginDir);
      } catch (e) {
        new import_obsidian8.Notice(t().noticeDbReadFailed + e.message);
        console.error(e);
        return;
      }
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        new import_obsidian8.Notice(t().noticeCurrentNoteNotFound(""));
        return;
      }
      const currentNoteName = activeFile.name;
      const noteTitleFormat = this.settings.exportTitle + ".md";
      const citeKey = parseCiteKeyFromNoteName(currentNoteName, noteTitleFormat);
      if (citeKey != null) {
        const entryIndex = data.items.findIndex(
          (item) => item.citationKey === citeKey
        );
        if (entryIndex != -1) {
          const currentEntry = data.items[entryIndex];
          if (!currentEntry) {
            new import_obsidian8.Notice(t().noticeCurrentNoteNotFound(currentNoteName));
            return;
          }
          yield this.createNote(currentEntry, data);
          new import_obsidian8.Notice(t().noticeCurrentNoteUpdated(currentNoteName));
        } else {
          new import_obsidian8.Notice(t().noticeCurrentNoteNotFound(currentNoteName));
        }
      } else {
        new import_obsidian8.Notice(t().noticeCiteKeyNotFound(currentNoteName));
      }
    });
  }
};
